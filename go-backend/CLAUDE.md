# Project Guidelines

This repository serves as a Go project template.

## Quick Start (New Project)

1. Clone and rename module in `go.mod`
2. Update import paths throughout codebase
3. Configure `application.yaml` for your environment
4. Define your GraphQL schema in `internal/graph/schema.graphqls`
5. Add migrations in `internal/storage/pg/migrations/`
6. Add sqlc queries in `internal/storage/pg/queries/<domain>/`
7. Run `make sqlc && make gqlgen`
8. Wire new services in `cmd/server/main.go`

## Project Structure

```
autoclip/
├── cmd/                           # Application binaries
│   └── server/                    # Main server binary
│       └── main.go
├── internal/                      # Private application code
│   ├── authz/                     # Authentication/authorization
│   ├── bootstrap/                 # Dependency injection setup (fx providers)
│   ├── graph/                     # GraphQL layer
│   │   ├── schema.graphqls        # GraphQL schema definitions
│   │   ├── schema.resolvers.go    # Resolver implementations
│   │   ├── resolver.go            # Resolver struct
│   │   ├── generated.go           # Auto-generated (do not edit)
│   │   └── model/
│   │       └── models_gen.go      # Auto-generated models (do not edit)
│   └── storage/
│       └── pg/
│           ├── queries/           # SQL query files for sqlc
│           │   └── <domain>/
│           │       └── <domain>.sql
│           ├── migrations/        # Database migrations (goose)
│           │   └── NNNN_<name>.sql
│           ├── generated/         # Auto-generated by sqlc (do not edit)
│           │   └── <domain>/
│           ├── database.go        # Database connection
│           └── migrations.go      # Migration runner
├── application.yaml               # Application configuration
├── sqlc.yaml                      # sqlc configuration
├── gqlgen.yml                     # gqlgen configuration
└── Makefile
```

## Dependency Injection (uber-go/fx)

All binaries use fx for dependency injection.

### IMPORTANT: No Wrapper Functions

**NEVER create wrapper functions in bootstrap that just call the original constructor.** Use the original package function directly in fx.Provide.

Bad (unnecessary wrapper):
```go
// bootstrap/auth.go - DON'T DO THIS
func NewAuthHandlers(svc *auth.Service, cfg auth.Config) *auth.Handlers {
    return auth.NewHandlers(svc, cfg)
}

// main.go
fx.Provide(bootstrap.NewAuthHandlers)
```

Good (use directly):
```go
// main.go
fx.Provide(auth.NewHandlers)
```

Only create bootstrap functions when actual adaptation is needed (e.g., combining multiple services into a router).

### Main function pattern

```go
package main

import (
    "github.com/augustdev/autoclip/internal/auth"
    "github.com/augustdev/autoclip/internal/bootstrap"
    "github.com/augustdev/autoclip/internal/storage/pg"
    "go.uber.org/fx"
)

func main() {
    fx.New(
        fx.Provide(
            bootstrap.NewLogger,
            bootstrap.NewConfig,
            pg.NewDatabase,
            auth.NewService,    // Use package constructors directly
            auth.NewHandlers,   // Not bootstrap wrappers
        ),
        fx.Invoke(
            bootstrap.StartServer,
        ),
    ).Run()
}
```

## Database

### Adding New Queries (sqlc)

1. Create SQL file in `internal/storage/pg/queries/<domain>/<domain>.sql`
2. Add sqlc configuration block to `sqlc.yaml`:
   ```yaml
   - engine: "postgresql"
     queries: "internal/storage/pg/queries/<domain>"
     schema: "internal/storage/pg/migrations"
     gen:
       go:
         package: "<domain>"
         out: "internal/storage/pg/generated/<domain>"
         sql_package: "pgx/v5"
         emit_json_tags: true
         emit_interface: true
         emit_empty_slices: true
   ```
3. Run `make sqlc`

### Adding New Migrations

1. Create migration file: `internal/storage/pg/migrations/NNNN_<name>.sql`
2. Use goose format with `-- +goose Up` and `-- +goose Down` annotations

## GraphQL

### Modifying Schema

1. Edit `internal/graph/schema.graphqls`
2. Run `make gqlgen`
3. Implement resolver methods in `internal/graph/schema.resolvers.go`

### Directives

- `@isAuthenticated` - Requires valid authentication token

## Configuration

### IMPORTANT: No mapstructure Tags

**NEVER use `mapstructure` struct tags.** Viper automatically maps lowercase yaml keys to Go struct fields. Use lowercase keys in yaml that match the lowercase version of your Go field names.

Example:
```yaml
# application.yaml
auth:
  jwtsecret: "secret"      # maps to JWTSecret
  sessioncookiename: "x"   # maps to SessionCookieName
```

```go
type Config struct {
    JWTSecret         string  // No tags needed
    SessionCookieName string
}
```

### Pattern

Each package defines its own `Config` struct. The `bootstrap.Config` aggregates all package configs using `fx.Out` for dependency injection.

**Package-level config** (e.g., `internal/storage/pg/database.go`):
```go
type DbConfig struct {
    URL             string
    MaxConns        int32
    MinConns        int32
    MaxConnLifetime time.Duration
    MaxConnIdleTime time.Duration
}
```

**Aggregated config** (`internal/bootstrap/config.go`):
```go
type Config struct {
    fx.Out

    GraphQLAPI GraphQLAPIConfig
    Db         pg.DbConfig
    // Add new package configs here
}
```

### Configuration Sources

1. `application.yaml` - Primary config file (viper)
2. Environment variables - Override yaml values using `_` as separator
   - Example: `DB_URL` overrides `db.url`
   - Example: `GRAPHQLAPI_PORT` overrides `graphqlapi.port`
3. `APPLICATION_CONFIG` env var - Custom config file path

### Adding New Configuration

1. Define `Config` struct in the package with `mapstructure` tags
2. Add corresponding section to `application.yaml`
3. Import and embed in `bootstrap.Config`
4. Update `NewConfig()` to unmarshal the new section

## Code Style

- NEVER add comments that restate what the code already says
  - Bad: `// EnvVar represents an environment variable for an application.`
  - Bad: `// NewClient creates a new client.`
  - Good: No comment needed when the name is self-explanatory
  - Good: Comment only when explaining WHY or non-obvious behavior
- Use meaningful variable and function names that are self-documenting
- Keep functions small and focused
- Follow standard Go conventions

## Adding a New Domain

Example: Adding an `orders` domain

1. **Migration**: Create `internal/storage/pg/migrations/0002_orders.sql`
2. **Queries**: Create `internal/storage/pg/queries/orders/orders.sql`
3. **sqlc config**: Add block to `sqlc.yaml`:
   ```yaml
   - engine: "postgresql"
     queries: "internal/storage/pg/queries/orders"
     schema: "internal/storage/pg/migrations"
     gen:
       go:
         package: "orders"
         out: "internal/storage/pg/generated/orders"
         sql_package: "pgx/v5"
         emit_json_tags: true
         emit_interface: true
         emit_empty_slices: true
   ```
4. **Generate**: `make sqlc`
5. **Service**: Create `internal/orders/service.go` with config and service logic
6. **GraphQL**: Add types/queries/mutations to `internal/graph/schema.graphqls`
7. **Generate**: `make gqlgen`
8. **Resolvers**: Implement in `internal/graph/schema.resolvers.go`
9. **Wire**: Add providers to `cmd/server/main.go`

## Make Commands

```bash
make run-server    # Run the server
make run-worker    # Run the Temporal worker
make sqlc          # Generate sqlc code
make gqlgen        # Generate GraphQL code
```

## Worker Binaries

There are multiple worker binaries — **do not confuse them**:

| Binary | Path | Task Queue | Purpose |
|--------|------|------------|---------|
| `k8s-worker` | `cmd/k8s-worker/main.go` | `k8s-native` | K8s deployments (build, deploy, delete) |
| `worker` | `cmd/worker/main.go` | `default` | Account workflows |

**The k8s deployment in `infra/k8s/temporal-worker.yml` runs `cmd/k8s-worker`, NOT `cmd/worker`.**

### Deploying the k8s-worker to the cluster

```bash
# 1. Build the correct binary
cd go-backend
GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build -o /tmp/k8s-worker ./cmd/k8s-worker

# 2. Copy into build context
cp /tmp/k8s-worker .tmp-k8s-worker-image/k8s-worker
cp application.yaml .tmp-k8s-worker-image/application.yaml

# 3. Build Docker image (no provenance to avoid ctr import issues)
docker build --platform linux/amd64 --provenance=false --sbom=false \
  -t registry.internal:5000/dp-system/temporal-worker:latest .tmp-k8s-worker-image/

# 4. Save, SCP, import, push to internal registry
docker save registry.internal:5000/dp-system/temporal-worker:latest -o /tmp/worker-image.tar
scp /tmp/worker-image.tar root@46.225.100.234:/tmp/worker-image.tar
ssh root@46.225.100.234 "k3s ctr images import /tmp/worker-image.tar && \
  k3s ctr images push --plain-http registry.internal:5000/dp-system/temporal-worker:latest && \
  rm /tmp/worker-image.tar"

# 5. Restart deployment
kubectl rollout restart deployment/temporal-worker -n dp-system
kubectl rollout status deployment/temporal-worker -n dp-system --timeout=120s

# 6. Verify correct task queue in logs
kubectl logs deployment/temporal-worker -n dp-system --tail=5
# Should show: TaskQueue k8s-native (NOT "default")
```

## Invisible Processes

When running `go run`, Go compiles the binary to a temp folder and executes it. The `go run` wrapper process and the actual binary are separate processes.

**Problem**: `pkill -f "cmd/worker"` only kills the `go run` wrapper, not the compiled binary running from `/var/folders/.../go-build.../b001/exe/main`.

**To find hidden Go binaries**:
```bash
ps aux | grep "go-build" | grep -v grep
```

**To kill all Go worker binaries**:
```bash
ps aux | grep "go-build" | grep -v grep | awk '{print $2}' | xargs kill -9
```

This is especially relevant for Temporal workers which maintain persistent connections - they'll keep showing as "live" in Temporal UI until properly killed.
