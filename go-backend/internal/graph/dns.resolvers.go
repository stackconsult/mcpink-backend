package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"
	"sync"

	"github.com/augustdev/autoclip/internal/authz"
	"github.com/augustdev/autoclip/internal/dns"
	"github.com/augustdev/autoclip/internal/graph/model"
)

// DelegateZone is the resolver for the delegateZone field.
func (r *mutationResolver) DelegateZone(ctx context.Context, zone string) (*model.DelegateZoneResult, error) {
	userID := authz.For(ctx).GetUserID()

	result, err := r.DNSService.DelegateZone(ctx, dns.DelegateZoneParams{
		UserID: userID,
		Zone:   zone,
	})
	if err != nil {
		return nil, err
	}

	return &model.DelegateZoneResult{
		ZoneID:     result.ZoneID,
		Zone:       result.Zone,
		Status:     result.Status,
		DNSRecords: toGQLDNSRecords(result.Records),
	}, nil
}

// VerifyDelegation is the resolver for the verifyDelegation field.
func (r *mutationResolver) VerifyDelegation(ctx context.Context, zone string) (*model.VerifyDelegationResult, error) {
	userID := authz.For(ctx).GetUserID()

	result, err := r.DNSService.VerifyDelegation(ctx, dns.VerifyDelegationParams{
		UserID: userID,
		Zone:   zone,
	})
	if err != nil {
		return nil, err
	}

	return &model.VerifyDelegationResult{
		ZoneID:     result.ZoneID,
		Zone:       result.Zone,
		Status:     result.Status,
		Message:    result.Message,
		DNSRecords: toGQLDNSRecords(result.Records),
	}, nil
}

// RemoveDelegation is the resolver for the removeDelegation field.
func (r *mutationResolver) RemoveDelegation(ctx context.Context, zone string) (*model.RemoveDelegationResult, error) {
	userID := authz.For(ctx).GetUserID()

	result, err := r.DNSService.RemoveDelegation(ctx, dns.RemoveDelegationParams{
		UserID: userID,
		Zone:   zone,
	})
	if err != nil {
		return nil, err
	}

	return &model.RemoveDelegationResult{
		ZoneID:  result.ZoneID,
		Message: result.Message,
	}, nil
}

// ListDelegatedZones is the resolver for the listDelegatedZones field.
func (r *queryResolver) ListDelegatedZones(ctx context.Context) ([]*model.DelegatedZone, error) {
	userID := authz.For(ctx).GetUserID()

	zones, err := r.DNSService.ListDelegations(ctx, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to list delegated zones: %w", err)
	}

	nameservers := r.DNSService.Nameservers()

	result := make([]*model.DelegatedZone, len(zones))

	var wg sync.WaitGroup
	for i, z := range zones {
		dz := &model.DelegatedZone{
			ID:        z.ID,
			Zone:      z.Zone,
			Status:    z.Status,
			Error:     z.LastError,
			CreatedAt: z.CreatedAt.Time,
		}
		result[i] = dz

		if z.Status != "active" {
			wg.Go(func() {
				txtVerified := z.VerifiedAt.Valid
				if !txtVerified {
					ok, _ := dns.VerifyTXT(z.Zone, z.VerificationToken)
					txtVerified = ok
				}

				nsStatus := dns.VerifyNSRecords(z.Zone, nameservers)

				var records []*model.DNSRecord
				if z.Status == "pending_verification" {
					records = append(records, &model.DNSRecord{
						Host:     "_dp-verify." + z.Zone,
						Type:     "TXT",
						Value:    "dp-verify=" + z.VerificationToken,
						Verified: txtVerified,
					})
				}
				for _, ns := range nameservers {
					records = append(records, &model.DNSRecord{
						Host:     z.Zone,
						Type:     "NS",
						Value:    ns,
						Verified: nsStatus[dns.NormalizeDomain(ns)],
					})
				}
				dz.DNSRecords = records
			})
		}
	}
	wg.Wait()

	return result, nil
}
