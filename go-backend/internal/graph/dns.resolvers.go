package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.87

import (
	"context"
	"fmt"
	"strings"
	"sync"

	"github.com/augustdev/autoclip/internal/authz"
	"github.com/augustdev/autoclip/internal/dns"
	"github.com/augustdev/autoclip/internal/graph/model"
)

// CreateHostedZone is the resolver for the createHostedZone field.
func (r *mutationResolver) CreateHostedZone(ctx context.Context, zone string) (*model.CreateHostedZoneResult, error) {
	userID := authz.For(ctx).GetUserID()

	result, err := r.DNSService.CreateHostedZone(ctx, dns.CreateHostedZoneParams{
		UserID: userID,
		Zone:   zone,
	})
	if err != nil {
		return nil, err
	}

	return &model.CreateHostedZoneResult{
		ZoneID:     result.ZoneID,
		Zone:       result.Zone,
		Status:     result.Status,
		DNSRecords: toGQLDNSRecords(result.Records),
	}, nil
}

// VerifyHostedZone is the resolver for the verifyHostedZone field.
func (r *mutationResolver) VerifyHostedZone(ctx context.Context, zone string) (*model.VerifyHostedZoneResult, error) {
	userID := authz.For(ctx).GetUserID()

	result, err := r.DNSService.VerifyHostedZone(ctx, dns.VerifyHostedZoneParams{
		UserID: userID,
		Zone:   zone,
	})
	if err != nil {
		return nil, err
	}

	return &model.VerifyHostedZoneResult{
		ZoneID:     result.ZoneID,
		Zone:       result.Zone,
		Status:     result.Status,
		Message:    result.Message,
		DNSRecords: toGQLDNSRecords(result.Records),
	}, nil
}

// DeleteHostedZone is the resolver for the deleteHostedZone field.
func (r *mutationResolver) DeleteHostedZone(ctx context.Context, zone string) (*model.DeleteHostedZoneResult, error) {
	userID := authz.For(ctx).GetUserID()

	result, err := r.DNSService.DeleteHostedZone(ctx, dns.DeleteHostedZoneParams{
		UserID: userID,
		Zone:   zone,
	})
	if err != nil {
		return nil, err
	}

	return &model.DeleteHostedZoneResult{
		ZoneID:  result.ZoneID,
		Message: result.Message,
	}, nil
}

// AddDNSRecord is the resolver for the addDnsRecord field.
func (r *mutationResolver) AddDNSRecord(ctx context.Context, zone string, name string, typeArg string, content string, ttl *int32) (*model.ZoneRecord, error) {
	userID := authz.For(ctx).GetUserID()

	ttlVal := 0
	if ttl != nil {
		ttlVal = int(*ttl)
	}

	result, err := r.DNSService.AddDnsRecord(ctx, dns.AddDnsRecordParams{
		UserID:  userID,
		Zone:    zone,
		Name:    name,
		Rrtype:  strings.ToUpper(typeArg),
		Content: content,
		TTL:     ttlVal,
	})
	if err != nil {
		return nil, err
	}

	return &model.ZoneRecord{
		ID:        result.Record.ID,
		Name:      result.Record.Name,
		Type:      result.Record.Rrtype,
		Content:   result.Record.Content,
		TTL:       int32(result.Record.Ttl),
		Managed:   result.Record.Managed,
		CreatedAt: result.Record.CreatedAt.Time,
	}, nil
}

// DeleteDNSRecord is the resolver for the deleteDnsRecord field.
func (r *mutationResolver) DeleteDNSRecord(ctx context.Context, zone string, recordID string) (bool, error) {
	userID := authz.For(ctx).GetUserID()

	err := r.DNSService.DeleteDnsRecord(ctx, dns.DeleteDnsRecordParams{
		UserID:   userID,
		Zone:     zone,
		RecordID: recordID,
	})
	if err != nil {
		return false, err
	}

	return true, nil
}

// ListHostedZones is the resolver for the listHostedZones field.
func (r *queryResolver) ListHostedZones(ctx context.Context) ([]*model.HostedZone, error) {
	userID := authz.For(ctx).GetUserID()

	zones, err := r.DNSService.ListHostedZones(ctx, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to list hosted zones: %w", err)
	}

	nameservers := r.DNSService.Nameservers()

	result := make([]*model.HostedZone, len(zones))

	var wg sync.WaitGroup
	for i, z := range zones {
		hz := &model.HostedZone{
			ID:        z.ID,
			Zone:      z.Zone,
			Status:    z.Status,
			Error:     z.LastError,
			Records:   []*model.ZoneRecord{},
			CreatedAt: z.CreatedAt.Time,
		}
		result[i] = hz

		wg.Go(func() {
			recs, err := r.DNSService.ListDnsRecords(ctx, dns.ListDnsRecordsParams{
				UserID: userID,
				Zone:   z.Zone,
			})
			if err == nil {
				zoneRecords := make([]*model.ZoneRecord, len(recs))
				for j, rec := range recs {
					zoneRecords[j] = &model.ZoneRecord{
						ID:        rec.ID,
						Name:      rec.Name,
						Type:      rec.Rrtype,
						Content:   rec.Content,
						TTL:       int32(rec.Ttl),
						Managed:   rec.Managed,
						CreatedAt: rec.CreatedAt.Time,
					}
				}
				hz.Records = zoneRecords
			}
		})

		if z.Status != "active" {
			wg.Go(func() {
				txtVerified := z.VerifiedAt.Valid
				if !txtVerified {
					ok, _ := dns.VerifyTXT(z.Zone, z.VerificationToken)
					txtVerified = ok
				}

				nsStatus := dns.VerifyNSRecords(z.Zone, nameservers)

				var records []*model.DNSRecord
				if z.Status == "pending_verification" {
					records = append(records, &model.DNSRecord{
						Host:     "_dp-verify." + z.Zone,
						Type:     "TXT",
						Value:    "dp-verify=" + z.VerificationToken,
						Verified: txtVerified,
					})
				}
				for _, ns := range nameservers {
					records = append(records, &model.DNSRecord{
						Host:     z.Zone,
						Type:     "NS",
						Value:    ns,
						Verified: nsStatus[dns.NormalizeDomain(ns)],
					})
				}
				hz.DNSRecords = records
			})
		}
	}
	wg.Wait()

	return result, nil
}
