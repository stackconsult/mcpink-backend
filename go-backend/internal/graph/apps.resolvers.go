package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"

	"github.com/augustdev/autoclip/internal/authz"
	"github.com/augustdev/autoclip/internal/graph/model"
	"github.com/augustdev/autoclip/internal/storage/pg/generated/apps"
)

// DeleteApp is the resolver for the deleteApp field.
func (r *mutationResolver) DeleteApp(ctx context.Context, name string, project *string) (*model.DeleteAppResult, error) {
	userID := authz.For(ctx).GetUserID()

	projectRef := "default"
	if project != nil && *project != "" {
		projectRef = *project
	}

	// Look up app by name and project
	app, err := r.AppQueries.GetAppByNameAndUserProject(ctx, apps.GetAppByNameAndUserProjectParams{
		Name:   &name,
		UserID: userID,
		Ref:    projectRef,
	})
	if err != nil {
		return nil, fmt.Errorf("app not found: %s in project %s", name, projectRef)
	}

	// Delete from Coolify if it was deployed
	if app.CoolifyAppUuid != nil && r.CoolifyClient != nil {
		if err := r.CoolifyClient.Applications.Delete(ctx, *app.CoolifyAppUuid); err != nil {
			r.Logger.Warn("failed to delete app from Coolify",
				"app_id", app.ID,
				"coolify_uuid", *app.CoolifyAppUuid,
				"error", err)
		}
	}

	// Soft delete in database
	_, err = r.AppQueries.SoftDeleteApp(ctx, app.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to delete app: %w", err)
	}

	appName := ""
	if app.Name != nil {
		appName = *app.Name
	}

	return &model.DeleteAppResult{
		AppID:   app.ID,
		Name:    appName,
		Message: "App deleted successfully",
	}, nil
}

// ListApps is the resolver for the listApps field.
func (r *queryResolver) ListApps(ctx context.Context, first *int32, after *string) (*model.AppConnection, error) {
	userID := authz.For(ctx).GetUserID()

	// Get total count
	totalCount, err := r.AppQueries.CountAppsByUserID(ctx, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to count apps: %w", err)
	}

	// For now, return all items (ignore pagination params)
	limit := int32(1000)
	offset := int32(0)

	dbApps, err := r.AppQueries.ListAppsByUserID(ctx, apps.ListAppsByUserIDParams{
		UserID: userID,
		Limit:  limit,
		Offset: offset,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list apps: %w", err)
	}

	nodes := make([]*model.App, len(dbApps))
	for i, dbApp := range dbApps {
		nodes[i] = dbAppToModel(&dbApp)
	}

	var startCursor, endCursor *string
	if len(nodes) > 0 {
		startCursor = &nodes[0].ID
		endCursor = &nodes[len(nodes)-1].ID
	}

	return &model.AppConnection{
		Nodes: nodes,
		PageInfo: &model.PageInfo{
			HasNextPage:     false,
			HasPreviousPage: false,
			StartCursor:     startCursor,
			EndCursor:       endCursor,
		},
		TotalCount: int32(totalCount),
	}, nil
}

// AppDetails is the resolver for the appDetails field.
func (r *queryResolver) AppDetails(ctx context.Context, id string) (*model.App, error) {
	userID := authz.For(ctx).GetUserID()

	dbApp, err := r.AppQueries.GetAppByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to get app: %w", err)
	}

	// Verify ownership
	if dbApp.UserID != userID {
		return nil, fmt.Errorf("app not found")
	}

	return dbAppToModel(&dbApp), nil
}
