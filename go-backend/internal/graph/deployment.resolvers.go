package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"
	"strconv"

	"github.com/augustdev/autoclip/internal/coolify"
	"github.com/augustdev/autoclip/internal/graph/model"
	"github.com/augustdev/autoclip/internal/helpers"
)

// Deploy is the resolver for the deploy field.
func (r *mutationResolver) Deploy(ctx context.Context, input model.DeployInput) (*model.DeployResult, error) {
	// For dev: use GitHub App UUID from config
	githubAppUUID := r.CoolifyClient.Config().GitHubAppUUID

	buildPack := coolify.BuildPackNixpacks
	if input.BuildPack != nil {
		switch *input.BuildPack {
		case model.BuildPackNixpacks:
			buildPack = coolify.BuildPackNixpacks
		case model.BuildPackDockerfile:
			buildPack = coolify.BuildPackDockerfile
		case model.BuildPackStatic:
			buildPack = coolify.BuildPackStatic
		case model.BuildPackDockerCompose:
			buildPack = coolify.BuildPackDockerCompose
		}
	}

	port := "3000"
	if input.Port != nil {
		port = strconv.Itoa(int(*input.Port))
	}

	req := &coolify.CreatePrivateGitHubAppRequest{
		ProjectUUID:     r.CoolifyClient.Config().ProjectUUID,
		ServerUUID:      input.ServerUUID,
		EnvironmentName: r.CoolifyClient.Config().EnvironmentName,
		GitHubAppUUID:   githubAppUUID,
		GitRepository:   input.Repo,
		GitBranch:       input.Branch,
		BuildPack:       buildPack,
		PortsExposes:    port,
	}

	if input.Name != nil {
		req.Name = *input.Name
	}
	if input.Memory != nil {
		req.LimitsMemory = *input.Memory
	}
	if input.CPU != nil {
		req.LimitsCPUs = *input.CPU
	}
	if input.InstallCommand != nil {
		req.InstallCommand = *input.InstallCommand
	}
	if input.BuildCommand != nil {
		req.BuildCommand = *input.BuildCommand
	}
	if input.StartCommand != nil {
		req.StartCommand = *input.StartCommand
	}
	if input.InstantDeploy != nil {
		req.InstantDeploy = input.InstantDeploy
	} else {
		req.InstantDeploy = helpers.Ptr(true)
	}

	createResp, err := r.CoolifyClient.Applications.CreatePrivateGitHubApp(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to create application: %w", err)
	}

	if len(input.EnvVars) > 0 {
		envReqs := make([]coolify.CreateEnvRequest, len(input.EnvVars))
		for i, ev := range input.EnvVars {
			envReqs[i] = coolify.CreateEnvRequest{
				Key:   ev.Key,
				Value: ev.Value,
			}
		}
		if err := r.CoolifyClient.Applications.BulkUpdateEnvs(ctx, createResp.UUID, &coolify.BulkUpdateEnvsRequest{
			Data: envReqs,
		}); err != nil {
			r.Logger.Error("failed to set environment variables", "error", err, "uuid", createResp.UUID)
		}
	}

	startResp, err := r.CoolifyClient.Applications.Start(ctx, createResp.UUID, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to start deployment: %w", err)
	}

	app, err := r.CoolifyClient.Applications.Get(ctx, createResp.UUID)
	if err != nil {
		return nil, fmt.Errorf("failed to get application: %w", err)
	}

	return &model.DeployResult{
		Deployment: &model.Deployment{
			UUID:      app.UUID,
			Name:      app.Name,
			Repo:      app.GitRepository,
			Branch:    app.GitBranch,
			Status:    app.Status,
			Fqdn:      app.FQDN,
			CreatedAt: &app.CreatedAt,
		},
		DeploymentUUID: &startResp.DeploymentUUID,
		Message:        "Deployment started",
	}, nil
}

// StopDeployment is the resolver for the stopDeployment field.
func (r *mutationResolver) StopDeployment(ctx context.Context, uuid string) (bool, error) {
	if err := r.CoolifyClient.Applications.Stop(ctx, uuid); err != nil {
		return false, fmt.Errorf("failed to stop deployment: %w", err)
	}

	return true, nil
}

// RestartDeployment is the resolver for the restartDeployment field.
func (r *mutationResolver) RestartDeployment(ctx context.Context, uuid string) (*model.DeployResult, error) {
	restartResp, err := r.CoolifyClient.Applications.Restart(ctx, uuid)
	if err != nil {
		return nil, fmt.Errorf("failed to restart deployment: %w", err)
	}

	app, err := r.CoolifyClient.Applications.Get(ctx, uuid)
	if err != nil {
		return nil, fmt.Errorf("failed to get application: %w", err)
	}

	return &model.DeployResult{
		Deployment: &model.Deployment{
			UUID:      app.UUID,
			Name:      app.Name,
			Repo:      app.GitRepository,
			Branch:    app.GitBranch,
			Status:    app.Status,
			Fqdn:      app.FQDN,
			CreatedAt: &app.CreatedAt,
		},
		DeploymentUUID: &restartResp.DeploymentUUID,
		Message:        restartResp.Message,
	}, nil
}

// DeleteDeployment is the resolver for the deleteDeployment field.
func (r *mutationResolver) DeleteDeployment(ctx context.Context, uuid string) (bool, error) {
	if err := r.CoolifyClient.Applications.Delete(ctx, uuid); err != nil {
		return false, fmt.Errorf("failed to delete deployment: %w", err)
	}

	return true, nil
}

// Deployment is the resolver for the deployment field.
func (r *queryResolver) Deployment(ctx context.Context, uuid string) (*model.Deployment, error) {
	app, err := r.CoolifyClient.Applications.Get(ctx, uuid)
	if err != nil {
		return nil, fmt.Errorf("failed to get deployment: %w", err)
	}

	return &model.Deployment{
		UUID:      app.UUID,
		Name:      app.Name,
		Repo:      app.GitRepository,
		Branch:    app.GitBranch,
		Status:    app.Status,
		Fqdn:      app.FQDN,
		CreatedAt: &app.CreatedAt,
	}, nil
}

// Deployments is the resolver for the deployments field.
func (r *queryResolver) Deployments(ctx context.Context) ([]*model.Deployment, error) {
	apps, err := r.CoolifyClient.Applications.List(ctx, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to list deployments: %w", err)
	}

	result := make([]*model.Deployment, len(apps))
	for i, app := range apps {
		result[i] = &model.Deployment{
			UUID:      app.UUID,
			Name:      app.Name,
			Repo:      app.GitRepository,
			Branch:    app.GitBranch,
			Status:    app.Status,
			Fqdn:      app.FQDN,
			CreatedAt: &app.CreatedAt,
		}
	}

	return result, nil
}
