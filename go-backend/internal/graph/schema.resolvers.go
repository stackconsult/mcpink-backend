package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"
	"time"

	"github.com/augustdev/autoclip/internal/authz"
	model1 "github.com/augustdev/autoclip/internal/graph/model"
)

// CreateAPIKey is the resolver for the createAPIKey field.
func (r *mutationResolver) CreateAPIKey(ctx context.Context, name string) (*model1.CreateAPIKeyResult, error) {
	result, err := r.AuthService.GenerateAPIKey(ctx, authz.For(ctx).GetUserID(), name)
	if err != nil {
		return nil, fmt.Errorf("failed to create API key: %w", err)
	}

	return &model1.CreateAPIKeyResult{
		APIKey: &model1.APIKey{
			ID:        result.ID,
			Name:      result.Name,
			Prefix:    result.Prefix,
			CreatedAt: result.CreatedAt,
		},
		Secret: result.FullKey,
	}, nil
}

// RevokeAPIKey is the resolver for the revokeAPIKey field.
func (r *mutationResolver) RevokeAPIKey(ctx context.Context, id string) (bool, error) {
	if err := r.AuthService.RevokeAPIKey(ctx, authz.For(ctx).GetUserID(), id); err != nil {
		return false, fmt.Errorf("failed to revoke API key: %w", err)
	}

	return true, nil
}

// RecheckGithubAppInstallation is the resolver for the recheckGithubAppInstallation field.
func (r *mutationResolver) RecheckGithubAppInstallation(ctx context.Context) (*string, error) {
	userID := authz.For(ctx).GetUserID()

	user, err := r.AuthService.GetUserByID(ctx, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	// Check with GitHub API if the user has installed the app
	installationID, err := r.GitHubAppService.GetUserInstallation(ctx, user.GithubUsername)
	if err != nil {
		r.Logger.Error("failed to check GitHub App installation", "error", err, "username", user.GithubUsername)
		return nil, nil
	}

	if installationID == 0 {
		// User has uninstalled - clear cached value
		if user.GithubAppInstallationID != nil {
			_ = r.AuthService.ClearGitHubAppInstallation(ctx, userID)
		}
		return nil, nil
	}

	// Update cache with new value
	if user.GithubAppInstallationID == nil || *user.GithubAppInstallationID != installationID {
		_ = r.AuthService.SetGitHubAppInstallation(ctx, userID, installationID)

		// Create Coolify GitHub App source if not already created
		if user.CoolifyGithubAppUuid == nil || *user.CoolifyGithubAppUuid == "" {
			_, err := r.AuthService.CreateCoolifyGitHubAppSource(ctx, userID, installationID, user.GithubUsername)
			if err != nil {
				r.Logger.Error("failed to create coolify github app source", "error", err, "user_id", userID)
			}
		}
	}

	id := fmt.Sprintf("%d", installationID)
	return &id, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model1.User, error) {
	user, err := r.AuthService.GetUserByID(ctx, authz.For(ctx).GetUserID())
	if err != nil {
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	return &model1.User{
		ID:             user.ID,
		GithubUsername: user.GithubUsername,
		AvatarURL:      user.AvatarUrl,
		CreatedAt:      user.CreatedAt.Time,
	}, nil
}

// MyAPIKeys is the resolver for the myAPIKeys field.
func (r *queryResolver) MyAPIKeys(ctx context.Context) ([]*model1.APIKey, error) {
	keys, err := r.AuthService.ListAPIKeys(ctx, authz.For(ctx).GetUserID())
	if err != nil {
		return nil, fmt.Errorf("failed to list API keys: %w", err)
	}

	result := make([]*model1.APIKey, len(keys))
	for i, key := range keys {
		var lastUsedAt *time.Time
		if key.LastUsedAt.Valid {
			t := key.LastUsedAt.Time
			lastUsedAt = &t
		}

		result[i] = &model1.APIKey{
			ID:         key.ID,
			Name:       key.Name,
			Prefix:     key.KeyPrefix,
			LastUsedAt: lastUsedAt,
			CreatedAt:  key.CreatedAt.Time,
		}
	}

	return result, nil
}

// GithubAppInstallationID is the resolver for the githubAppInstallationId field.
func (r *userResolver) GithubAppInstallationID(ctx context.Context, obj *model1.User) (*string, error) {
	userID := authz.For(ctx).GetUserID()

	user, err := r.AuthService.GetUserByID(ctx, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	// Return cached value if present
	if user.GithubAppInstallationID != nil {
		id := fmt.Sprintf("%d", *user.GithubAppInstallationID)
		return &id, nil
	}

	return nil, nil
}

// GithubScopes is the resolver for the githubScopes field.
func (r *userResolver) GithubScopes(ctx context.Context, obj *model1.User) ([]string, error) {
	user, err := r.AuthService.GetUserByID(ctx, authz.For(ctx).GetUserID())
	if err != nil {
		return []string{}, nil
	}
	return user.GithubScopes, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
