package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.87

import (
	"context"
	"fmt"
	"time"

	"github.com/augustdev/autoclip/internal/authz"
	model1 "github.com/augustdev/autoclip/internal/graph/model"
)

// CreateAPIKey is the resolver for the createAPIKey field.
func (r *mutationResolver) CreateAPIKey(ctx context.Context, name string) (*model1.CreateAPIKeyResult, error) {
	result, err := r.AuthService.GenerateAPIKey(ctx, authz.For(ctx).GetUserID(), name)
	if err != nil {
		return nil, fmt.Errorf("failed to create API key: %w", err)
	}

	return &model1.CreateAPIKeyResult{
		APIKey: &model1.APIKey{
			ID:        result.ID,
			Name:      result.Name,
			Prefix:    result.Prefix,
			CreatedAt: result.CreatedAt,
		},
		Secret: result.FullKey,
	}, nil
}

// RevokeAPIKey is the resolver for the revokeAPIKey field.
func (r *mutationResolver) RevokeAPIKey(ctx context.Context, id string) (bool, error) {
	if err := r.AuthService.RevokeAPIKey(ctx, authz.For(ctx).GetUserID(), id); err != nil {
		return false, fmt.Errorf("failed to revoke API key: %w", err)
	}

	return true, nil
}

// RecheckGithubAppInstallation is the resolver for the recheckGithubAppInstallation field.
func (r *mutationResolver) RecheckGithubAppInstallation(ctx context.Context) (*string, error) {
	userID := authz.For(ctx).GetUserID()

	user, err := r.AuthService.GetUserByID(ctx, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	if user.GithubUsername == nil || *user.GithubUsername == "" {
		return nil, nil
	}

	creds, err := r.AuthService.GetGitHubCredsByUserID(ctx, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to get github creds: %w", err)
	}

	installationID, err := r.GitHubAppService.GetUserInstallation(ctx, *user.GithubUsername)
	if err != nil {
		r.Logger.Error("failed to check GitHub App installation", "error", err, "username", *user.GithubUsername)
		return nil, nil
	}

	storedID := int64(0)
	if creds.GithubAppInstallationID != nil {
		storedID = *creds.GithubAppInstallationID
	}

	if storedID != installationID {
		if _, err := r.AuthService.SyncGitHubAppInstallation(ctx, userID, installationID, *user.GithubUsername); err != nil {
			r.Logger.Error("failed to sync github app installation", "error", err, "user_id", userID)
		}
	}

	if installationID == 0 {
		return nil, nil
	}

	id := fmt.Sprintf("%d", installationID)
	return &id, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model1.User, error) {
	uid := authz.For(ctx).GetUserID()
	me, err := r.AuthService.GetMeByID(ctx, uid)
	if err != nil {
		// Auto-create: get user details from Firebase Admin SDK
		if r.FirebaseAuth != nil {
			firebaseUser, fbErr := r.FirebaseAuth.GetUser(ctx, uid)
			if fbErr != nil {
				return nil, fmt.Errorf("failed to get Firebase user: %w", fbErr)
			}
			if _, err = r.AuthService.GetOrCreateUser(ctx, uid, firebaseUser.Email, firebaseUser.DisplayName, firebaseUser.PhotoURL); err != nil {
				return nil, err
			}
			me, err = r.AuthService.GetMeByID(ctx, uid)
			if err != nil {
				return nil, fmt.Errorf("failed to get user after creation: %w", err)
			}
		} else {
			return nil, fmt.Errorf("failed to get user: %w", err)
		}
	}

	var githubAppInstallationID *string
	if me.GithubAppInstallationID != nil {
		id := fmt.Sprintf("%d", *me.GithubAppInstallationID)
		githubAppInstallationID = &id
	}

	scopes := me.GithubOauthScopes
	if scopes == nil {
		scopes = []string{}
	}

	return &model1.User{
		ID:                      me.ID,
		Email:                   me.Email,
		DisplayName:             me.DisplayName,
		GithubUsername:          me.GithubUsername,
		AvatarURL:               me.AvatarUrl,
		CreatedAt:               me.CreatedAt.Time,
		GithubAppInstallationID: githubAppInstallationID,
		GithubScopes:            scopes,
	}, nil
}

// MyAPIKeys is the resolver for the myAPIKeys field.
func (r *queryResolver) MyAPIKeys(ctx context.Context) ([]*model1.APIKey, error) {
	keys, err := r.AuthService.ListAPIKeys(ctx, authz.For(ctx).GetUserID())
	if err != nil {
		return nil, fmt.Errorf("failed to list API keys: %w", err)
	}

	result := make([]*model1.APIKey, len(keys))
	for i, key := range keys {
		var lastUsedAt *time.Time
		if key.LastUsedAt.Valid {
			t := key.LastUsedAt.Time
			lastUsedAt = &t
		}

		result[i] = &model1.APIKey{
			ID:         key.ID,
			Name:       key.Name,
			Prefix:     key.KeyPrefix,
			LastUsedAt: lastUsedAt,
			CreatedAt:  key.CreatedAt.Time,
		}
	}

	return result, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
