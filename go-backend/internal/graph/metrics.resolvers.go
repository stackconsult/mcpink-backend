package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.87

import (
	"context"
	"fmt"

	"github.com/augustdev/autoclip/internal/authz"
	"github.com/augustdev/autoclip/internal/graph/model"
	"github.com/augustdev/autoclip/internal/k8sdeployments"
	"github.com/augustdev/autoclip/internal/storage/pg/generated/services"
)

// ServiceMetrics is the resolver for the serviceMetrics field.
func (r *queryResolver) ServiceMetrics(ctx context.Context, serviceID string, timeRange model.MetricTimeRange) (*model.ServiceMetrics, error) {
	userID := authz.For(ctx).GetUserID()

	svc, err := r.ServiceQueries.GetServiceMetricsContext(ctx, services.GetServiceMetricsContextParams{
		ID:     serviceID,
		UserID: userID,
	})
	if err != nil {
		return nil, fmt.Errorf("service not found")
	}

	namespace := k8sdeployments.NamespaceName(svc.UserID, svc.ProjectRef)

	svcName := ""
	if svc.ServiceName != nil {
		svcName = *svc.ServiceName
	}
	serviceName := k8sdeployments.ServiceName(svcName)

	start, end, step, err := resolveTimeRange(timeRange)
	if err != nil {
		return nil, err
	}

	metrics, err := r.PrometheusClient.GetServiceMetrics(ctx, namespace, serviceName, start, end, step)
	if err != nil {
		return nil, fmt.Errorf("metrics temporarily unavailable")
	}

	return &model.ServiceMetrics{
		CPUUsage:                   toModelSeries(metrics.CPUUsage),
		MemoryUsageMb:              toModelSeries(metrics.MemoryUsageMB),
		NetworkReceiveBytesPerSec:  toModelSeries(metrics.NetworkReceiveBytesPerSec),
		NetworkTransmitBytesPerSec: toModelSeries(metrics.NetworkTransmitBytesPerSec),
		MemoryLimitMb:              parseMemoryToMB(svc.Memory),
		CPULimitVCPUs:              parseCPUToVCPUs(svc.Vcpus),
	}, nil
}
