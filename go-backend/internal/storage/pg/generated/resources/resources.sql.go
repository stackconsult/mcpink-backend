// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: resources.sql

package resources

import (
	"context"
)

const countResourcesByUser = `-- name: CountResourcesByUser :one
SELECT COUNT(*) FROM resources WHERE user_id = $1
`

func (q *Queries) CountResourcesByUser(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRow(ctx, countResourcesByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createResource = `-- name: CreateResource :one
INSERT INTO resources (
    user_id, project_id, name, type, provider, region, external_id, credentials, metadata, status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
RETURNING id, user_id, project_id, name, type, provider, region, external_id, credentials, metadata, status, created_at, updated_at
`

type CreateResourceParams struct {
	UserID      string  `json:"user_id"`
	ProjectID   *string `json:"project_id"`
	Name        string  `json:"name"`
	Type        string  `json:"type"`
	Provider    string  `json:"provider"`
	Region      string  `json:"region"`
	ExternalID  *string `json:"external_id"`
	Credentials string  `json:"credentials"`
	Metadata    []byte  `json:"metadata"`
	Status      string  `json:"status"`
}

func (q *Queries) CreateResource(ctx context.Context, arg CreateResourceParams) (Resource, error) {
	row := q.db.QueryRow(ctx, createResource,
		arg.UserID,
		arg.ProjectID,
		arg.Name,
		arg.Type,
		arg.Provider,
		arg.Region,
		arg.ExternalID,
		arg.Credentials,
		arg.Metadata,
		arg.Status,
	)
	var i Resource
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProjectID,
		&i.Name,
		&i.Type,
		&i.Provider,
		&i.Region,
		&i.ExternalID,
		&i.Credentials,
		&i.Metadata,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteResource = `-- name: DeleteResource :exec
DELETE FROM resources WHERE id = $1
`

func (q *Queries) DeleteResource(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteResource, id)
	return err
}

const deleteResourceByUserAndID = `-- name: DeleteResourceByUserAndID :exec
DELETE FROM resources WHERE id = $1 AND user_id = $2
`

type DeleteResourceByUserAndIDParams struct {
	ID     string `json:"id"`
	UserID string `json:"user_id"`
}

func (q *Queries) DeleteResourceByUserAndID(ctx context.Context, arg DeleteResourceByUserAndIDParams) error {
	_, err := q.db.Exec(ctx, deleteResourceByUserAndID, arg.ID, arg.UserID)
	return err
}

const getResourceByID = `-- name: GetResourceByID :one
SELECT id, user_id, project_id, name, type, provider, region, external_id, credentials, metadata, status, created_at, updated_at FROM resources WHERE id = $1
`

func (q *Queries) GetResourceByID(ctx context.Context, id string) (Resource, error) {
	row := q.db.QueryRow(ctx, getResourceByID, id)
	var i Resource
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProjectID,
		&i.Name,
		&i.Type,
		&i.Provider,
		&i.Region,
		&i.ExternalID,
		&i.Credentials,
		&i.Metadata,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getResourceByUserAndName = `-- name: GetResourceByUserAndName :one
SELECT id, user_id, project_id, name, type, provider, region, external_id, credentials, metadata, status, created_at, updated_at FROM resources WHERE user_id = $1 AND name = $2
`

type GetResourceByUserAndNameParams struct {
	UserID string `json:"user_id"`
	Name   string `json:"name"`
}

func (q *Queries) GetResourceByUserAndName(ctx context.Context, arg GetResourceByUserAndNameParams) (Resource, error) {
	row := q.db.QueryRow(ctx, getResourceByUserAndName, arg.UserID, arg.Name)
	var i Resource
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProjectID,
		&i.Name,
		&i.Type,
		&i.Provider,
		&i.Region,
		&i.ExternalID,
		&i.Credentials,
		&i.Metadata,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listResourcesByProject = `-- name: ListResourcesByProject :many
SELECT id, user_id, project_id, name, type, provider, region, external_id, credentials, metadata, status, created_at, updated_at FROM resources
WHERE project_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListResourcesByProjectParams struct {
	ProjectID *string `json:"project_id"`
	Limit     int32   `json:"limit"`
	Offset    int32   `json:"offset"`
}

func (q *Queries) ListResourcesByProject(ctx context.Context, arg ListResourcesByProjectParams) ([]Resource, error) {
	rows, err := q.db.Query(ctx, listResourcesByProject, arg.ProjectID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Resource{}
	for rows.Next() {
		var i Resource
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProjectID,
			&i.Name,
			&i.Type,
			&i.Provider,
			&i.Region,
			&i.ExternalID,
			&i.Credentials,
			&i.Metadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listResourcesByUser = `-- name: ListResourcesByUser :many
SELECT id, user_id, project_id, name, type, provider, region, external_id, credentials, metadata, status, created_at, updated_at FROM resources
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListResourcesByUserParams struct {
	UserID string `json:"user_id"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListResourcesByUser(ctx context.Context, arg ListResourcesByUserParams) ([]Resource, error) {
	rows, err := q.db.Query(ctx, listResourcesByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Resource{}
	for rows.Next() {
		var i Resource
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProjectID,
			&i.Name,
			&i.Type,
			&i.Provider,
			&i.Region,
			&i.ExternalID,
			&i.Credentials,
			&i.Metadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listResourcesByUserAndType = `-- name: ListResourcesByUserAndType :many
SELECT id, user_id, project_id, name, type, provider, region, external_id, credentials, metadata, status, created_at, updated_at FROM resources
WHERE user_id = $1 AND type = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListResourcesByUserAndTypeParams struct {
	UserID string `json:"user_id"`
	Type   string `json:"type"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListResourcesByUserAndType(ctx context.Context, arg ListResourcesByUserAndTypeParams) ([]Resource, error) {
	rows, err := q.db.Query(ctx, listResourcesByUserAndType,
		arg.UserID,
		arg.Type,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Resource{}
	for rows.Next() {
		var i Resource
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProjectID,
			&i.Name,
			&i.Type,
			&i.Provider,
			&i.Region,
			&i.ExternalID,
			&i.Credentials,
			&i.Metadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateResourceAfterProvisioning = `-- name: UpdateResourceAfterProvisioning :one
UPDATE resources
SET external_id = $2, credentials = $3, metadata = $4, status = 'active', updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, project_id, name, type, provider, region, external_id, credentials, metadata, status, created_at, updated_at
`

type UpdateResourceAfterProvisioningParams struct {
	ID          string  `json:"id"`
	ExternalID  *string `json:"external_id"`
	Credentials string  `json:"credentials"`
	Metadata    []byte  `json:"metadata"`
}

func (q *Queries) UpdateResourceAfterProvisioning(ctx context.Context, arg UpdateResourceAfterProvisioningParams) (Resource, error) {
	row := q.db.QueryRow(ctx, updateResourceAfterProvisioning,
		arg.ID,
		arg.ExternalID,
		arg.Credentials,
		arg.Metadata,
	)
	var i Resource
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProjectID,
		&i.Name,
		&i.Type,
		&i.Provider,
		&i.Region,
		&i.ExternalID,
		&i.Credentials,
		&i.Metadata,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateResourceCredentials = `-- name: UpdateResourceCredentials :exec
UPDATE resources
SET credentials = $2, external_id = $3, metadata = $4, status = $5, updated_at = NOW()
WHERE id = $1
`

type UpdateResourceCredentialsParams struct {
	ID          string  `json:"id"`
	Credentials string  `json:"credentials"`
	ExternalID  *string `json:"external_id"`
	Metadata    []byte  `json:"metadata"`
	Status      string  `json:"status"`
}

func (q *Queries) UpdateResourceCredentials(ctx context.Context, arg UpdateResourceCredentialsParams) error {
	_, err := q.db.Exec(ctx, updateResourceCredentials,
		arg.ID,
		arg.Credentials,
		arg.ExternalID,
		arg.Metadata,
		arg.Status,
	)
	return err
}

const updateResourceStatus = `-- name: UpdateResourceStatus :exec
UPDATE resources
SET status = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateResourceStatusParams struct {
	ID     string `json:"id"`
	Status string `json:"status"`
}

func (q *Queries) UpdateResourceStatus(ctx context.Context, arg UpdateResourceStatusParams) error {
	_, err := q.db.Exec(ctx, updateResourceStatus, arg.ID, arg.Status)
	return err
}
