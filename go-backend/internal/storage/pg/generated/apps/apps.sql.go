// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: apps.sql

package apps

import (
	"context"
)

const countAppsByProjectID = `-- name: CountAppsByProjectID :one
SELECT COUNT(*) FROM apps WHERE project_id = $1
`

func (q *Queries) CountAppsByProjectID(ctx context.Context, projectID string) (int64, error) {
	row := q.db.QueryRow(ctx, countAppsByProjectID, projectID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAppsByUserID = `-- name: CountAppsByUserID :one
SELECT COUNT(*) FROM apps WHERE user_id = $1
`

func (q *Queries) CountAppsByUserID(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRow(ctx, countAppsByUserID, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createApp = `-- name: CreateApp :one
INSERT INTO apps (
    id, user_id, project_id, repo, branch, server_uuid, name, build_pack, port, env_vars, workflow_id, workflow_run_id, build_status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, 'queued'
)
RETURNING id, user_id, coolify_app_uuid, build_status, runtime_status, error_message, repo, branch, server_uuid, name, build_pack, port, env_vars, fqdn, workflow_id, workflow_run_id, created_at, updated_at, project_id, commit_hash
`

type CreateAppParams struct {
	ID            string  `json:"id"`
	UserID        string  `json:"user_id"`
	ProjectID     string  `json:"project_id"`
	Repo          string  `json:"repo"`
	Branch        string  `json:"branch"`
	ServerUuid    string  `json:"server_uuid"`
	Name          *string `json:"name"`
	BuildPack     string  `json:"build_pack"`
	Port          string  `json:"port"`
	EnvVars       []byte  `json:"env_vars"`
	WorkflowID    string  `json:"workflow_id"`
	WorkflowRunID *string `json:"workflow_run_id"`
}

func (q *Queries) CreateApp(ctx context.Context, arg CreateAppParams) (App, error) {
	row := q.db.QueryRow(ctx, createApp,
		arg.ID,
		arg.UserID,
		arg.ProjectID,
		arg.Repo,
		arg.Branch,
		arg.ServerUuid,
		arg.Name,
		arg.BuildPack,
		arg.Port,
		arg.EnvVars,
		arg.WorkflowID,
		arg.WorkflowRunID,
	)
	var i App
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CoolifyAppUuid,
		&i.BuildStatus,
		&i.RuntimeStatus,
		&i.ErrorMessage,
		&i.Repo,
		&i.Branch,
		&i.ServerUuid,
		&i.Name,
		&i.BuildPack,
		&i.Port,
		&i.EnvVars,
		&i.Fqdn,
		&i.WorkflowID,
		&i.WorkflowRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectID,
		&i.CommitHash,
	)
	return i, err
}

const deleteApp = `-- name: DeleteApp :exec
DELETE FROM apps WHERE id = $1
`

func (q *Queries) DeleteApp(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteApp, id)
	return err
}

const getAppByCoolifyUUID = `-- name: GetAppByCoolifyUUID :one
SELECT id, user_id, coolify_app_uuid, build_status, runtime_status, error_message, repo, branch, server_uuid, name, build_pack, port, env_vars, fqdn, workflow_id, workflow_run_id, created_at, updated_at, project_id, commit_hash FROM apps WHERE coolify_app_uuid = $1
`

func (q *Queries) GetAppByCoolifyUUID(ctx context.Context, coolifyAppUuid *string) (App, error) {
	row := q.db.QueryRow(ctx, getAppByCoolifyUUID, coolifyAppUuid)
	var i App
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CoolifyAppUuid,
		&i.BuildStatus,
		&i.RuntimeStatus,
		&i.ErrorMessage,
		&i.Repo,
		&i.Branch,
		&i.ServerUuid,
		&i.Name,
		&i.BuildPack,
		&i.Port,
		&i.EnvVars,
		&i.Fqdn,
		&i.WorkflowID,
		&i.WorkflowRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectID,
		&i.CommitHash,
	)
	return i, err
}

const getAppByID = `-- name: GetAppByID :one
SELECT id, user_id, coolify_app_uuid, build_status, runtime_status, error_message, repo, branch, server_uuid, name, build_pack, port, env_vars, fqdn, workflow_id, workflow_run_id, created_at, updated_at, project_id, commit_hash FROM apps WHERE id = $1
`

func (q *Queries) GetAppByID(ctx context.Context, id string) (App, error) {
	row := q.db.QueryRow(ctx, getAppByID, id)
	var i App
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CoolifyAppUuid,
		&i.BuildStatus,
		&i.RuntimeStatus,
		&i.ErrorMessage,
		&i.Repo,
		&i.Branch,
		&i.ServerUuid,
		&i.Name,
		&i.BuildPack,
		&i.Port,
		&i.EnvVars,
		&i.Fqdn,
		&i.WorkflowID,
		&i.WorkflowRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectID,
		&i.CommitHash,
	)
	return i, err
}

const getAppByNameAndProject = `-- name: GetAppByNameAndProject :one
SELECT id, user_id, coolify_app_uuid, build_status, runtime_status, error_message, repo, branch, server_uuid, name, build_pack, port, env_vars, fqdn, workflow_id, workflow_run_id, created_at, updated_at, project_id, commit_hash FROM apps
WHERE name = $1 AND project_id = $2 AND coolify_app_uuid IS NOT NULL
`

type GetAppByNameAndProjectParams struct {
	Name      *string `json:"name"`
	ProjectID string  `json:"project_id"`
}

func (q *Queries) GetAppByNameAndProject(ctx context.Context, arg GetAppByNameAndProjectParams) (App, error) {
	row := q.db.QueryRow(ctx, getAppByNameAndProject, arg.Name, arg.ProjectID)
	var i App
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CoolifyAppUuid,
		&i.BuildStatus,
		&i.RuntimeStatus,
		&i.ErrorMessage,
		&i.Repo,
		&i.Branch,
		&i.ServerUuid,
		&i.Name,
		&i.BuildPack,
		&i.Port,
		&i.EnvVars,
		&i.Fqdn,
		&i.WorkflowID,
		&i.WorkflowRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectID,
		&i.CommitHash,
	)
	return i, err
}

const getAppByNameAndUserProject = `-- name: GetAppByNameAndUserProject :one
SELECT a.id, a.user_id, a.coolify_app_uuid, a.build_status, a.runtime_status, a.error_message, a.repo, a.branch, a.server_uuid, a.name, a.build_pack, a.port, a.env_vars, a.fqdn, a.workflow_id, a.workflow_run_id, a.created_at, a.updated_at, a.project_id, a.commit_hash FROM apps a
JOIN projects p ON a.project_id = p.id
WHERE a.name = $1
  AND p.user_id = $2
  AND (p.ref = $3 OR ($3 = 'default' AND p.is_default = true))
LIMIT 1
`

type GetAppByNameAndUserProjectParams struct {
	Name   *string `json:"name"`
	UserID string  `json:"user_id"`
	Ref    string  `json:"ref"`
}

func (q *Queries) GetAppByNameAndUserProject(ctx context.Context, arg GetAppByNameAndUserProjectParams) (App, error) {
	row := q.db.QueryRow(ctx, getAppByNameAndUserProject, arg.Name, arg.UserID, arg.Ref)
	var i App
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CoolifyAppUuid,
		&i.BuildStatus,
		&i.RuntimeStatus,
		&i.ErrorMessage,
		&i.Repo,
		&i.Branch,
		&i.ServerUuid,
		&i.Name,
		&i.BuildPack,
		&i.Port,
		&i.EnvVars,
		&i.Fqdn,
		&i.WorkflowID,
		&i.WorkflowRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectID,
		&i.CommitHash,
	)
	return i, err
}

const getAppByWorkflowID = `-- name: GetAppByWorkflowID :one
SELECT id, user_id, coolify_app_uuid, build_status, runtime_status, error_message, repo, branch, server_uuid, name, build_pack, port, env_vars, fqdn, workflow_id, workflow_run_id, created_at, updated_at, project_id, commit_hash FROM apps WHERE workflow_id = $1
`

func (q *Queries) GetAppByWorkflowID(ctx context.Context, workflowID string) (App, error) {
	row := q.db.QueryRow(ctx, getAppByWorkflowID, workflowID)
	var i App
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CoolifyAppUuid,
		&i.BuildStatus,
		&i.RuntimeStatus,
		&i.ErrorMessage,
		&i.Repo,
		&i.Branch,
		&i.ServerUuid,
		&i.Name,
		&i.BuildPack,
		&i.Port,
		&i.EnvVars,
		&i.Fqdn,
		&i.WorkflowID,
		&i.WorkflowRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectID,
		&i.CommitHash,
	)
	return i, err
}

const getAppsByRepoBranch = `-- name: GetAppsByRepoBranch :many
SELECT id, user_id, coolify_app_uuid, build_status, runtime_status, error_message, repo, branch, server_uuid, name, build_pack, port, env_vars, fqdn, workflow_id, workflow_run_id, created_at, updated_at, project_id, commit_hash FROM apps
WHERE repo = $1 AND branch = $2 AND coolify_app_uuid IS NOT NULL
`

type GetAppsByRepoBranchParams struct {
	Repo   string `json:"repo"`
	Branch string `json:"branch"`
}

func (q *Queries) GetAppsByRepoBranch(ctx context.Context, arg GetAppsByRepoBranchParams) ([]App, error) {
	rows, err := q.db.Query(ctx, getAppsByRepoBranch, arg.Repo, arg.Branch)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []App{}
	for rows.Next() {
		var i App
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CoolifyAppUuid,
			&i.BuildStatus,
			&i.RuntimeStatus,
			&i.ErrorMessage,
			&i.Repo,
			&i.Branch,
			&i.ServerUuid,
			&i.Name,
			&i.BuildPack,
			&i.Port,
			&i.EnvVars,
			&i.Fqdn,
			&i.WorkflowID,
			&i.WorkflowRunID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectID,
			&i.CommitHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAppsByProjectID = `-- name: ListAppsByProjectID :many
SELECT id, user_id, coolify_app_uuid, build_status, runtime_status, error_message, repo, branch, server_uuid, name, build_pack, port, env_vars, fqdn, workflow_id, workflow_run_id, created_at, updated_at, project_id, commit_hash FROM apps
WHERE project_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListAppsByProjectIDParams struct {
	ProjectID string `json:"project_id"`
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
}

func (q *Queries) ListAppsByProjectID(ctx context.Context, arg ListAppsByProjectIDParams) ([]App, error) {
	rows, err := q.db.Query(ctx, listAppsByProjectID, arg.ProjectID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []App{}
	for rows.Next() {
		var i App
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CoolifyAppUuid,
			&i.BuildStatus,
			&i.RuntimeStatus,
			&i.ErrorMessage,
			&i.Repo,
			&i.Branch,
			&i.ServerUuid,
			&i.Name,
			&i.BuildPack,
			&i.Port,
			&i.EnvVars,
			&i.Fqdn,
			&i.WorkflowID,
			&i.WorkflowRunID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectID,
			&i.CommitHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAppsByUserID = `-- name: ListAppsByUserID :many
SELECT id, user_id, coolify_app_uuid, build_status, runtime_status, error_message, repo, branch, server_uuid, name, build_pack, port, env_vars, fqdn, workflow_id, workflow_run_id, created_at, updated_at, project_id, commit_hash FROM apps
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListAppsByUserIDParams struct {
	UserID string `json:"user_id"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListAppsByUserID(ctx context.Context, arg ListAppsByUserIDParams) ([]App, error) {
	rows, err := q.db.Query(ctx, listAppsByUserID, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []App{}
	for rows.Next() {
		var i App
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CoolifyAppUuid,
			&i.BuildStatus,
			&i.RuntimeStatus,
			&i.ErrorMessage,
			&i.Repo,
			&i.Branch,
			&i.ServerUuid,
			&i.Name,
			&i.BuildPack,
			&i.Port,
			&i.EnvVars,
			&i.Fqdn,
			&i.WorkflowID,
			&i.WorkflowRunID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectID,
			&i.CommitHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAppCoolifyUUID = `-- name: UpdateAppCoolifyUUID :one
UPDATE apps
SET coolify_app_uuid = $2, build_status = 'building', updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, coolify_app_uuid, build_status, runtime_status, error_message, repo, branch, server_uuid, name, build_pack, port, env_vars, fqdn, workflow_id, workflow_run_id, created_at, updated_at, project_id, commit_hash
`

type UpdateAppCoolifyUUIDParams struct {
	ID             string  `json:"id"`
	CoolifyAppUuid *string `json:"coolify_app_uuid"`
}

func (q *Queries) UpdateAppCoolifyUUID(ctx context.Context, arg UpdateAppCoolifyUUIDParams) (App, error) {
	row := q.db.QueryRow(ctx, updateAppCoolifyUUID, arg.ID, arg.CoolifyAppUuid)
	var i App
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CoolifyAppUuid,
		&i.BuildStatus,
		&i.RuntimeStatus,
		&i.ErrorMessage,
		&i.Repo,
		&i.Branch,
		&i.ServerUuid,
		&i.Name,
		&i.BuildPack,
		&i.Port,
		&i.EnvVars,
		&i.Fqdn,
		&i.WorkflowID,
		&i.WorkflowRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectID,
		&i.CommitHash,
	)
	return i, err
}

const updateAppFailed = `-- name: UpdateAppFailed :one
UPDATE apps
SET build_status = 'failed', error_message = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, coolify_app_uuid, build_status, runtime_status, error_message, repo, branch, server_uuid, name, build_pack, port, env_vars, fqdn, workflow_id, workflow_run_id, created_at, updated_at, project_id, commit_hash
`

type UpdateAppFailedParams struct {
	ID           string  `json:"id"`
	ErrorMessage *string `json:"error_message"`
}

func (q *Queries) UpdateAppFailed(ctx context.Context, arg UpdateAppFailedParams) (App, error) {
	row := q.db.QueryRow(ctx, updateAppFailed, arg.ID, arg.ErrorMessage)
	var i App
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CoolifyAppUuid,
		&i.BuildStatus,
		&i.RuntimeStatus,
		&i.ErrorMessage,
		&i.Repo,
		&i.Branch,
		&i.ServerUuid,
		&i.Name,
		&i.BuildPack,
		&i.Port,
		&i.EnvVars,
		&i.Fqdn,
		&i.WorkflowID,
		&i.WorkflowRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectID,
		&i.CommitHash,
	)
	return i, err
}

const updateAppRedeploying = `-- name: UpdateAppRedeploying :one
UPDATE apps
SET build_status = 'building', updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, coolify_app_uuid, build_status, runtime_status, error_message, repo, branch, server_uuid, name, build_pack, port, env_vars, fqdn, workflow_id, workflow_run_id, created_at, updated_at, project_id, commit_hash
`

func (q *Queries) UpdateAppRedeploying(ctx context.Context, id string) (App, error) {
	row := q.db.QueryRow(ctx, updateAppRedeploying, id)
	var i App
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CoolifyAppUuid,
		&i.BuildStatus,
		&i.RuntimeStatus,
		&i.ErrorMessage,
		&i.Repo,
		&i.Branch,
		&i.ServerUuid,
		&i.Name,
		&i.BuildPack,
		&i.Port,
		&i.EnvVars,
		&i.Fqdn,
		&i.WorkflowID,
		&i.WorkflowRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectID,
		&i.CommitHash,
	)
	return i, err
}

const updateAppRunning = `-- name: UpdateAppRunning :one
UPDATE apps
SET build_status = 'success', runtime_status = 'running', fqdn = $2, commit_hash = $3, updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, coolify_app_uuid, build_status, runtime_status, error_message, repo, branch, server_uuid, name, build_pack, port, env_vars, fqdn, workflow_id, workflow_run_id, created_at, updated_at, project_id, commit_hash
`

type UpdateAppRunningParams struct {
	ID         string  `json:"id"`
	Fqdn       *string `json:"fqdn"`
	CommitHash *string `json:"commit_hash"`
}

func (q *Queries) UpdateAppRunning(ctx context.Context, arg UpdateAppRunningParams) (App, error) {
	row := q.db.QueryRow(ctx, updateAppRunning, arg.ID, arg.Fqdn, arg.CommitHash)
	var i App
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CoolifyAppUuid,
		&i.BuildStatus,
		&i.RuntimeStatus,
		&i.ErrorMessage,
		&i.Repo,
		&i.Branch,
		&i.ServerUuid,
		&i.Name,
		&i.BuildPack,
		&i.Port,
		&i.EnvVars,
		&i.Fqdn,
		&i.WorkflowID,
		&i.WorkflowRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectID,
		&i.CommitHash,
	)
	return i, err
}

const updateBuildStatus = `-- name: UpdateBuildStatus :one
UPDATE apps
SET build_status = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, coolify_app_uuid, build_status, runtime_status, error_message, repo, branch, server_uuid, name, build_pack, port, env_vars, fqdn, workflow_id, workflow_run_id, created_at, updated_at, project_id, commit_hash
`

type UpdateBuildStatusParams struct {
	ID          string `json:"id"`
	BuildStatus string `json:"build_status"`
}

func (q *Queries) UpdateBuildStatus(ctx context.Context, arg UpdateBuildStatusParams) (App, error) {
	row := q.db.QueryRow(ctx, updateBuildStatus, arg.ID, arg.BuildStatus)
	var i App
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CoolifyAppUuid,
		&i.BuildStatus,
		&i.RuntimeStatus,
		&i.ErrorMessage,
		&i.Repo,
		&i.Branch,
		&i.ServerUuid,
		&i.Name,
		&i.BuildPack,
		&i.Port,
		&i.EnvVars,
		&i.Fqdn,
		&i.WorkflowID,
		&i.WorkflowRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectID,
		&i.CommitHash,
	)
	return i, err
}

const updateRuntimeStatus = `-- name: UpdateRuntimeStatus :one
UPDATE apps
SET runtime_status = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, coolify_app_uuid, build_status, runtime_status, error_message, repo, branch, server_uuid, name, build_pack, port, env_vars, fqdn, workflow_id, workflow_run_id, created_at, updated_at, project_id, commit_hash
`

type UpdateRuntimeStatusParams struct {
	ID            string  `json:"id"`
	RuntimeStatus *string `json:"runtime_status"`
}

func (q *Queries) UpdateRuntimeStatus(ctx context.Context, arg UpdateRuntimeStatusParams) (App, error) {
	row := q.db.QueryRow(ctx, updateRuntimeStatus, arg.ID, arg.RuntimeStatus)
	var i App
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CoolifyAppUuid,
		&i.BuildStatus,
		&i.RuntimeStatus,
		&i.ErrorMessage,
		&i.Repo,
		&i.Branch,
		&i.ServerUuid,
		&i.Name,
		&i.BuildPack,
		&i.Port,
		&i.EnvVars,
		&i.Fqdn,
		&i.WorkflowID,
		&i.WorkflowRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectID,
		&i.CommitHash,
	)
	return i, err
}

const updateWorkflowRunID = `-- name: UpdateWorkflowRunID :exec
UPDATE apps
SET workflow_run_id = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateWorkflowRunIDParams struct {
	ID            string  `json:"id"`
	WorkflowRunID *string `json:"workflow_run_id"`
}

func (q *Queries) UpdateWorkflowRunID(ctx context.Context, arg UpdateWorkflowRunIDParams) error {
	_, err := q.db.Exec(ctx, updateWorkflowRunID, arg.ID, arg.WorkflowRunID)
	return err
}
