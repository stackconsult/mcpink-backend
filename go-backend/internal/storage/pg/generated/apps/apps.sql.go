// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: apps.sql

package apps

import (
	"context"
)

const clearAppBuildProgress = `-- name: ClearAppBuildProgress :exec
UPDATE apps
SET build_progress = NULL, updated_at = NOW()
WHERE id = $1 AND is_deleted = false
`

func (q *Queries) ClearAppBuildProgress(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, clearAppBuildProgress, id)
	return err
}

const countAppsByProjectID = `-- name: CountAppsByProjectID :one
SELECT COUNT(*) FROM apps WHERE project_id = $1 AND is_deleted = false
`

func (q *Queries) CountAppsByProjectID(ctx context.Context, projectID string) (int64, error) {
	row := q.db.QueryRow(ctx, countAppsByProjectID, projectID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAppsByUserID = `-- name: CountAppsByUserID :one
SELECT COUNT(*) FROM apps WHERE user_id = $1 AND is_deleted = false
`

func (q *Queries) CountAppsByUserID(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRow(ctx, countAppsByUserID, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createApp = `-- name: CreateApp :one
INSERT INTO apps (
    id, user_id, project_id, repo, branch, server_uuid, name, build_pack, port, env_vars, workflow_id, workflow_run_id, build_status, git_provider, publish_directory, memory, cpu
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, 'queued', $13, $14, $15, $16
)
RETURNING id, user_id, build_status, runtime_status, error_message, repo, branch, server_uuid, name, build_pack, port, env_vars, fqdn, workflow_id, workflow_run_id, created_at, updated_at, project_id, commit_hash, is_deleted, git_provider, custom_domain, build_progress, publish_directory, memory, cpu
`

type CreateAppParams struct {
	ID               string  `json:"id"`
	UserID           string  `json:"user_id"`
	ProjectID        string  `json:"project_id"`
	Repo             string  `json:"repo"`
	Branch           string  `json:"branch"`
	ServerUuid       string  `json:"server_uuid"`
	Name             *string `json:"name"`
	BuildPack        string  `json:"build_pack"`
	Port             string  `json:"port"`
	EnvVars          []byte  `json:"env_vars"`
	WorkflowID       string  `json:"workflow_id"`
	WorkflowRunID    *string `json:"workflow_run_id"`
	GitProvider      string  `json:"git_provider"`
	PublishDirectory *string `json:"publish_directory"`
	Memory           string  `json:"memory"`
	Cpu              string  `json:"cpu"`
}

func (q *Queries) CreateApp(ctx context.Context, arg CreateAppParams) (App, error) {
	row := q.db.QueryRow(ctx, createApp,
		arg.ID,
		arg.UserID,
		arg.ProjectID,
		arg.Repo,
		arg.Branch,
		arg.ServerUuid,
		arg.Name,
		arg.BuildPack,
		arg.Port,
		arg.EnvVars,
		arg.WorkflowID,
		arg.WorkflowRunID,
		arg.GitProvider,
		arg.PublishDirectory,
		arg.Memory,
		arg.Cpu,
	)
	var i App
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BuildStatus,
		&i.RuntimeStatus,
		&i.ErrorMessage,
		&i.Repo,
		&i.Branch,
		&i.ServerUuid,
		&i.Name,
		&i.BuildPack,
		&i.Port,
		&i.EnvVars,
		&i.Fqdn,
		&i.WorkflowID,
		&i.WorkflowRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectID,
		&i.CommitHash,
		&i.IsDeleted,
		&i.GitProvider,
		&i.CustomDomain,
		&i.BuildProgress,
		&i.PublishDirectory,
		&i.Memory,
		&i.Cpu,
	)
	return i, err
}

const deleteApp = `-- name: DeleteApp :exec
DELETE FROM apps WHERE id = $1
`

func (q *Queries) DeleteApp(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteApp, id)
	return err
}

const getAppByID = `-- name: GetAppByID :one
SELECT id, user_id, build_status, runtime_status, error_message, repo, branch, server_uuid, name, build_pack, port, env_vars, fqdn, workflow_id, workflow_run_id, created_at, updated_at, project_id, commit_hash, is_deleted, git_provider, custom_domain, build_progress, publish_directory, memory, cpu FROM apps WHERE id = $1 AND is_deleted = false
`

func (q *Queries) GetAppByID(ctx context.Context, id string) (App, error) {
	row := q.db.QueryRow(ctx, getAppByID, id)
	var i App
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BuildStatus,
		&i.RuntimeStatus,
		&i.ErrorMessage,
		&i.Repo,
		&i.Branch,
		&i.ServerUuid,
		&i.Name,
		&i.BuildPack,
		&i.Port,
		&i.EnvVars,
		&i.Fqdn,
		&i.WorkflowID,
		&i.WorkflowRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectID,
		&i.CommitHash,
		&i.IsDeleted,
		&i.GitProvider,
		&i.CustomDomain,
		&i.BuildProgress,
		&i.PublishDirectory,
		&i.Memory,
		&i.Cpu,
	)
	return i, err
}

const getAppByNameAndProject = `-- name: GetAppByNameAndProject :one
SELECT id, user_id, build_status, runtime_status, error_message, repo, branch, server_uuid, name, build_pack, port, env_vars, fqdn, workflow_id, workflow_run_id, created_at, updated_at, project_id, commit_hash, is_deleted, git_provider, custom_domain, build_progress, publish_directory, memory, cpu FROM apps
WHERE name = $1 AND project_id = $2 AND is_deleted = false
`

type GetAppByNameAndProjectParams struct {
	Name      *string `json:"name"`
	ProjectID string  `json:"project_id"`
}

func (q *Queries) GetAppByNameAndProject(ctx context.Context, arg GetAppByNameAndProjectParams) (App, error) {
	row := q.db.QueryRow(ctx, getAppByNameAndProject, arg.Name, arg.ProjectID)
	var i App
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BuildStatus,
		&i.RuntimeStatus,
		&i.ErrorMessage,
		&i.Repo,
		&i.Branch,
		&i.ServerUuid,
		&i.Name,
		&i.BuildPack,
		&i.Port,
		&i.EnvVars,
		&i.Fqdn,
		&i.WorkflowID,
		&i.WorkflowRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectID,
		&i.CommitHash,
		&i.IsDeleted,
		&i.GitProvider,
		&i.CustomDomain,
		&i.BuildProgress,
		&i.PublishDirectory,
		&i.Memory,
		&i.Cpu,
	)
	return i, err
}

const getAppByNameAndUserProject = `-- name: GetAppByNameAndUserProject :one
SELECT a.id, a.user_id, a.build_status, a.runtime_status, a.error_message, a.repo, a.branch, a.server_uuid, a.name, a.build_pack, a.port, a.env_vars, a.fqdn, a.workflow_id, a.workflow_run_id, a.created_at, a.updated_at, a.project_id, a.commit_hash, a.is_deleted, a.git_provider, a.custom_domain, a.build_progress, a.publish_directory, a.memory, a.cpu FROM apps a
JOIN projects p ON a.project_id = p.id
WHERE a.name = $1
  AND p.user_id = $2
  AND (p.ref = $3 OR ($3 = 'default' AND p.is_default = true))
  AND a.is_deleted = false
ORDER BY a.updated_at DESC, a.created_at DESC, a.id DESC
LIMIT 1
`

type GetAppByNameAndUserProjectParams struct {
	Name   *string `json:"name"`
	UserID string  `json:"user_id"`
	Ref    string  `json:"ref"`
}

func (q *Queries) GetAppByNameAndUserProject(ctx context.Context, arg GetAppByNameAndUserProjectParams) (App, error) {
	row := q.db.QueryRow(ctx, getAppByNameAndUserProject, arg.Name, arg.UserID, arg.Ref)
	var i App
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BuildStatus,
		&i.RuntimeStatus,
		&i.ErrorMessage,
		&i.Repo,
		&i.Branch,
		&i.ServerUuid,
		&i.Name,
		&i.BuildPack,
		&i.Port,
		&i.EnvVars,
		&i.Fqdn,
		&i.WorkflowID,
		&i.WorkflowRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectID,
		&i.CommitHash,
		&i.IsDeleted,
		&i.GitProvider,
		&i.CustomDomain,
		&i.BuildProgress,
		&i.PublishDirectory,
		&i.Memory,
		&i.Cpu,
	)
	return i, err
}

const getAppByWorkflowID = `-- name: GetAppByWorkflowID :one
SELECT id, user_id, build_status, runtime_status, error_message, repo, branch, server_uuid, name, build_pack, port, env_vars, fqdn, workflow_id, workflow_run_id, created_at, updated_at, project_id, commit_hash, is_deleted, git_provider, custom_domain, build_progress, publish_directory, memory, cpu FROM apps WHERE workflow_id = $1 AND is_deleted = false
`

func (q *Queries) GetAppByWorkflowID(ctx context.Context, workflowID string) (App, error) {
	row := q.db.QueryRow(ctx, getAppByWorkflowID, workflowID)
	var i App
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BuildStatus,
		&i.RuntimeStatus,
		&i.ErrorMessage,
		&i.Repo,
		&i.Branch,
		&i.ServerUuid,
		&i.Name,
		&i.BuildPack,
		&i.Port,
		&i.EnvVars,
		&i.Fqdn,
		&i.WorkflowID,
		&i.WorkflowRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectID,
		&i.CommitHash,
		&i.IsDeleted,
		&i.GitProvider,
		&i.CustomDomain,
		&i.BuildProgress,
		&i.PublishDirectory,
		&i.Memory,
		&i.Cpu,
	)
	return i, err
}

const getAppsByRepoBranch = `-- name: GetAppsByRepoBranch :many
SELECT id, user_id, build_status, runtime_status, error_message, repo, branch, server_uuid, name, build_pack, port, env_vars, fqdn, workflow_id, workflow_run_id, created_at, updated_at, project_id, commit_hash, is_deleted, git_provider, custom_domain, build_progress, publish_directory, memory, cpu FROM apps
WHERE repo = $1 AND branch = $2 AND is_deleted = false
`

type GetAppsByRepoBranchParams struct {
	Repo   string `json:"repo"`
	Branch string `json:"branch"`
}

func (q *Queries) GetAppsByRepoBranch(ctx context.Context, arg GetAppsByRepoBranchParams) ([]App, error) {
	rows, err := q.db.Query(ctx, getAppsByRepoBranch, arg.Repo, arg.Branch)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []App{}
	for rows.Next() {
		var i App
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BuildStatus,
			&i.RuntimeStatus,
			&i.ErrorMessage,
			&i.Repo,
			&i.Branch,
			&i.ServerUuid,
			&i.Name,
			&i.BuildPack,
			&i.Port,
			&i.EnvVars,
			&i.Fqdn,
			&i.WorkflowID,
			&i.WorkflowRunID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectID,
			&i.CommitHash,
			&i.IsDeleted,
			&i.GitProvider,
			&i.CustomDomain,
			&i.BuildProgress,
			&i.PublishDirectory,
			&i.Memory,
			&i.Cpu,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAppsByRepoBranchProvider = `-- name: GetAppsByRepoBranchProvider :many
SELECT id, user_id, build_status, runtime_status, error_message, repo, branch, server_uuid, name, build_pack, port, env_vars, fqdn, workflow_id, workflow_run_id, created_at, updated_at, project_id, commit_hash, is_deleted, git_provider, custom_domain, build_progress, publish_directory, memory, cpu FROM apps
WHERE repo = $1 AND branch = $2 AND git_provider = $3 AND is_deleted = false
`

type GetAppsByRepoBranchProviderParams struct {
	Repo        string `json:"repo"`
	Branch      string `json:"branch"`
	GitProvider string `json:"git_provider"`
}

func (q *Queries) GetAppsByRepoBranchProvider(ctx context.Context, arg GetAppsByRepoBranchProviderParams) ([]App, error) {
	rows, err := q.db.Query(ctx, getAppsByRepoBranchProvider, arg.Repo, arg.Branch, arg.GitProvider)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []App{}
	for rows.Next() {
		var i App
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BuildStatus,
			&i.RuntimeStatus,
			&i.ErrorMessage,
			&i.Repo,
			&i.Branch,
			&i.ServerUuid,
			&i.Name,
			&i.BuildPack,
			&i.Port,
			&i.EnvVars,
			&i.Fqdn,
			&i.WorkflowID,
			&i.WorkflowRunID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectID,
			&i.CommitHash,
			&i.IsDeleted,
			&i.GitProvider,
			&i.CustomDomain,
			&i.BuildProgress,
			&i.PublishDirectory,
			&i.Memory,
			&i.Cpu,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAppsByProjectID = `-- name: ListAppsByProjectID :many
SELECT id, user_id, build_status, runtime_status, error_message, repo, branch, server_uuid, name, build_pack, port, env_vars, fqdn, workflow_id, workflow_run_id, created_at, updated_at, project_id, commit_hash, is_deleted, git_provider, custom_domain, build_progress, publish_directory, memory, cpu FROM apps
WHERE project_id = $1 AND is_deleted = false
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListAppsByProjectIDParams struct {
	ProjectID string `json:"project_id"`
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
}

func (q *Queries) ListAppsByProjectID(ctx context.Context, arg ListAppsByProjectIDParams) ([]App, error) {
	rows, err := q.db.Query(ctx, listAppsByProjectID, arg.ProjectID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []App{}
	for rows.Next() {
		var i App
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BuildStatus,
			&i.RuntimeStatus,
			&i.ErrorMessage,
			&i.Repo,
			&i.Branch,
			&i.ServerUuid,
			&i.Name,
			&i.BuildPack,
			&i.Port,
			&i.EnvVars,
			&i.Fqdn,
			&i.WorkflowID,
			&i.WorkflowRunID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectID,
			&i.CommitHash,
			&i.IsDeleted,
			&i.GitProvider,
			&i.CustomDomain,
			&i.BuildProgress,
			&i.PublishDirectory,
			&i.Memory,
			&i.Cpu,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAppsByUserID = `-- name: ListAppsByUserID :many
SELECT id, user_id, build_status, runtime_status, error_message, repo, branch, server_uuid, name, build_pack, port, env_vars, fqdn, workflow_id, workflow_run_id, created_at, updated_at, project_id, commit_hash, is_deleted, git_provider, custom_domain, build_progress, publish_directory, memory, cpu FROM apps
WHERE user_id = $1 AND is_deleted = false
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListAppsByUserIDParams struct {
	UserID string `json:"user_id"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListAppsByUserID(ctx context.Context, arg ListAppsByUserIDParams) ([]App, error) {
	rows, err := q.db.Query(ctx, listAppsByUserID, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []App{}
	for rows.Next() {
		var i App
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BuildStatus,
			&i.RuntimeStatus,
			&i.ErrorMessage,
			&i.Repo,
			&i.Branch,
			&i.ServerUuid,
			&i.Name,
			&i.BuildPack,
			&i.Port,
			&i.EnvVars,
			&i.Fqdn,
			&i.WorkflowID,
			&i.WorkflowRunID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectID,
			&i.CommitHash,
			&i.IsDeleted,
			&i.GitProvider,
			&i.CustomDomain,
			&i.BuildProgress,
			&i.PublishDirectory,
			&i.Memory,
			&i.Cpu,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteApp = `-- name: SoftDeleteApp :one
UPDATE apps
SET is_deleted = true, updated_at = NOW()
WHERE id = $1 AND is_deleted = false
RETURNING id, user_id, build_status, runtime_status, error_message, repo, branch, server_uuid, name, build_pack, port, env_vars, fqdn, workflow_id, workflow_run_id, created_at, updated_at, project_id, commit_hash, is_deleted, git_provider, custom_domain, build_progress, publish_directory, memory, cpu
`

func (q *Queries) SoftDeleteApp(ctx context.Context, id string) (App, error) {
	row := q.db.QueryRow(ctx, softDeleteApp, id)
	var i App
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BuildStatus,
		&i.RuntimeStatus,
		&i.ErrorMessage,
		&i.Repo,
		&i.Branch,
		&i.ServerUuid,
		&i.Name,
		&i.BuildPack,
		&i.Port,
		&i.EnvVars,
		&i.Fqdn,
		&i.WorkflowID,
		&i.WorkflowRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectID,
		&i.CommitHash,
		&i.IsDeleted,
		&i.GitProvider,
		&i.CustomDomain,
		&i.BuildProgress,
		&i.PublishDirectory,
		&i.Memory,
		&i.Cpu,
	)
	return i, err
}

const updateAppBuildProgress = `-- name: UpdateAppBuildProgress :exec
UPDATE apps
SET build_progress = $2, updated_at = NOW()
WHERE id = $1 AND is_deleted = false
`

type UpdateAppBuildProgressParams struct {
	ID            string `json:"id"`
	BuildProgress []byte `json:"build_progress"`
}

func (q *Queries) UpdateAppBuildProgress(ctx context.Context, arg UpdateAppBuildProgressParams) error {
	_, err := q.db.Exec(ctx, updateAppBuildProgress, arg.ID, arg.BuildProgress)
	return err
}

const updateAppFailed = `-- name: UpdateAppFailed :one
UPDATE apps
SET build_status = 'failed', error_message = $2, updated_at = NOW()
WHERE id = $1 AND is_deleted = false
RETURNING id, user_id, build_status, runtime_status, error_message, repo, branch, server_uuid, name, build_pack, port, env_vars, fqdn, workflow_id, workflow_run_id, created_at, updated_at, project_id, commit_hash, is_deleted, git_provider, custom_domain, build_progress, publish_directory, memory, cpu
`

type UpdateAppFailedParams struct {
	ID           string  `json:"id"`
	ErrorMessage *string `json:"error_message"`
}

func (q *Queries) UpdateAppFailed(ctx context.Context, arg UpdateAppFailedParams) (App, error) {
	row := q.db.QueryRow(ctx, updateAppFailed, arg.ID, arg.ErrorMessage)
	var i App
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BuildStatus,
		&i.RuntimeStatus,
		&i.ErrorMessage,
		&i.Repo,
		&i.Branch,
		&i.ServerUuid,
		&i.Name,
		&i.BuildPack,
		&i.Port,
		&i.EnvVars,
		&i.Fqdn,
		&i.WorkflowID,
		&i.WorkflowRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectID,
		&i.CommitHash,
		&i.IsDeleted,
		&i.GitProvider,
		&i.CustomDomain,
		&i.BuildProgress,
		&i.PublishDirectory,
		&i.Memory,
		&i.Cpu,
	)
	return i, err
}

const updateAppRedeploying = `-- name: UpdateAppRedeploying :one
UPDATE apps
SET build_status = 'building', updated_at = NOW()
WHERE id = $1 AND is_deleted = false
RETURNING id, user_id, build_status, runtime_status, error_message, repo, branch, server_uuid, name, build_pack, port, env_vars, fqdn, workflow_id, workflow_run_id, created_at, updated_at, project_id, commit_hash, is_deleted, git_provider, custom_domain, build_progress, publish_directory, memory, cpu
`

func (q *Queries) UpdateAppRedeploying(ctx context.Context, id string) (App, error) {
	row := q.db.QueryRow(ctx, updateAppRedeploying, id)
	var i App
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BuildStatus,
		&i.RuntimeStatus,
		&i.ErrorMessage,
		&i.Repo,
		&i.Branch,
		&i.ServerUuid,
		&i.Name,
		&i.BuildPack,
		&i.Port,
		&i.EnvVars,
		&i.Fqdn,
		&i.WorkflowID,
		&i.WorkflowRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectID,
		&i.CommitHash,
		&i.IsDeleted,
		&i.GitProvider,
		&i.CustomDomain,
		&i.BuildProgress,
		&i.PublishDirectory,
		&i.Memory,
		&i.Cpu,
	)
	return i, err
}

const updateAppRunning = `-- name: UpdateAppRunning :one
UPDATE apps
SET build_status = 'success', runtime_status = 'running', fqdn = $2, commit_hash = $3, updated_at = NOW()
WHERE id = $1 AND is_deleted = false
RETURNING id, user_id, build_status, runtime_status, error_message, repo, branch, server_uuid, name, build_pack, port, env_vars, fqdn, workflow_id, workflow_run_id, created_at, updated_at, project_id, commit_hash, is_deleted, git_provider, custom_domain, build_progress, publish_directory, memory, cpu
`

type UpdateAppRunningParams struct {
	ID         string  `json:"id"`
	Fqdn       *string `json:"fqdn"`
	CommitHash *string `json:"commit_hash"`
}

func (q *Queries) UpdateAppRunning(ctx context.Context, arg UpdateAppRunningParams) (App, error) {
	row := q.db.QueryRow(ctx, updateAppRunning, arg.ID, arg.Fqdn, arg.CommitHash)
	var i App
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BuildStatus,
		&i.RuntimeStatus,
		&i.ErrorMessage,
		&i.Repo,
		&i.Branch,
		&i.ServerUuid,
		&i.Name,
		&i.BuildPack,
		&i.Port,
		&i.EnvVars,
		&i.Fqdn,
		&i.WorkflowID,
		&i.WorkflowRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectID,
		&i.CommitHash,
		&i.IsDeleted,
		&i.GitProvider,
		&i.CustomDomain,
		&i.BuildProgress,
		&i.PublishDirectory,
		&i.Memory,
		&i.Cpu,
	)
	return i, err
}

const updateBuildStatus = `-- name: UpdateBuildStatus :one
UPDATE apps
SET build_status = $2, updated_at = NOW()
WHERE id = $1 AND is_deleted = false
RETURNING id, user_id, build_status, runtime_status, error_message, repo, branch, server_uuid, name, build_pack, port, env_vars, fqdn, workflow_id, workflow_run_id, created_at, updated_at, project_id, commit_hash, is_deleted, git_provider, custom_domain, build_progress, publish_directory, memory, cpu
`

type UpdateBuildStatusParams struct {
	ID          string `json:"id"`
	BuildStatus string `json:"build_status"`
}

func (q *Queries) UpdateBuildStatus(ctx context.Context, arg UpdateBuildStatusParams) (App, error) {
	row := q.db.QueryRow(ctx, updateBuildStatus, arg.ID, arg.BuildStatus)
	var i App
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BuildStatus,
		&i.RuntimeStatus,
		&i.ErrorMessage,
		&i.Repo,
		&i.Branch,
		&i.ServerUuid,
		&i.Name,
		&i.BuildPack,
		&i.Port,
		&i.EnvVars,
		&i.Fqdn,
		&i.WorkflowID,
		&i.WorkflowRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectID,
		&i.CommitHash,
		&i.IsDeleted,
		&i.GitProvider,
		&i.CustomDomain,
		&i.BuildProgress,
		&i.PublishDirectory,
		&i.Memory,
		&i.Cpu,
	)
	return i, err
}

const updateRuntimeStatus = `-- name: UpdateRuntimeStatus :one
UPDATE apps
SET runtime_status = $2, updated_at = NOW()
WHERE id = $1 AND is_deleted = false
RETURNING id, user_id, build_status, runtime_status, error_message, repo, branch, server_uuid, name, build_pack, port, env_vars, fqdn, workflow_id, workflow_run_id, created_at, updated_at, project_id, commit_hash, is_deleted, git_provider, custom_domain, build_progress, publish_directory, memory, cpu
`

type UpdateRuntimeStatusParams struct {
	ID            string  `json:"id"`
	RuntimeStatus *string `json:"runtime_status"`
}

func (q *Queries) UpdateRuntimeStatus(ctx context.Context, arg UpdateRuntimeStatusParams) (App, error) {
	row := q.db.QueryRow(ctx, updateRuntimeStatus, arg.ID, arg.RuntimeStatus)
	var i App
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BuildStatus,
		&i.RuntimeStatus,
		&i.ErrorMessage,
		&i.Repo,
		&i.Branch,
		&i.ServerUuid,
		&i.Name,
		&i.BuildPack,
		&i.Port,
		&i.EnvVars,
		&i.Fqdn,
		&i.WorkflowID,
		&i.WorkflowRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectID,
		&i.CommitHash,
		&i.IsDeleted,
		&i.GitProvider,
		&i.CustomDomain,
		&i.BuildProgress,
		&i.PublishDirectory,
		&i.Memory,
		&i.Cpu,
	)
	return i, err
}

const updateWorkflowRunID = `-- name: UpdateWorkflowRunID :exec
UPDATE apps
SET workflow_run_id = $2, updated_at = NOW()
WHERE id = $1 AND is_deleted = false
`

type UpdateWorkflowRunIDParams struct {
	ID            string  `json:"id"`
	WorkflowRunID *string `json:"workflow_run_id"`
}

func (q *Queries) UpdateWorkflowRunID(ctx context.Context, arg UpdateWorkflowRunIDParams) error {
	_, err := q.db.Exec(ctx, updateWorkflowRunID, arg.ID, arg.WorkflowRunID)
	return err
}
