// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: delegatedzones.sql

package delegatedzones

import (
	"context"
)

const create = `-- name: Create :one
INSERT INTO delegated_zones (user_id, zone, verification_token)
VALUES ($1, $2, $3) RETURNING id, user_id, zone, status, verification_token, wildcard_cert_secret, cert_issued_at, verified_at, delegated_at, expires_at, last_error, created_at, updated_at
`

type CreateParams struct {
	UserID            string `json:"user_id"`
	Zone              string `json:"zone"`
	VerificationToken string `json:"verification_token"`
}

func (q *Queries) Create(ctx context.Context, arg CreateParams) (DelegatedZone, error) {
	row := q.db.QueryRow(ctx, create, arg.UserID, arg.Zone, arg.VerificationToken)
	var i DelegatedZone
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Zone,
		&i.Status,
		&i.VerificationToken,
		&i.WildcardCertSecret,
		&i.CertIssuedAt,
		&i.VerifiedAt,
		&i.DelegatedAt,
		&i.ExpiresAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const delete = `-- name: Delete :exec
DELETE FROM delegated_zones WHERE id = $1
`

func (q *Queries) Delete(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, delete, id)
	return err
}

const expireStale = `-- name: ExpireStale :exec
UPDATE delegated_zones
SET status = 'failed',
    last_error = 'expired',
    updated_at = NOW()
WHERE status IN ('pending_verification', 'pending_delegation')
  AND expires_at < NOW()
`

func (q *Queries) ExpireStale(ctx context.Context) error {
	_, err := q.db.Exec(ctx, expireStale)
	return err
}

const findMatchingZoneForDomain = `-- name: FindMatchingZoneForDomain :one
SELECT id, user_id, zone, status, verification_token, wildcard_cert_secret, cert_issued_at, verified_at, delegated_at, expires_at, last_error, created_at, updated_at FROM delegated_zones
WHERE user_id = $1
  AND status = 'active'
  AND lower($2) LIKE '%.' || lower(zone)
ORDER BY length(zone) DESC
LIMIT 1
`

type FindMatchingZoneForDomainParams struct {
	UserID string `json:"user_id"`
	Lower  string `json:"lower"`
}

func (q *Queries) FindMatchingZoneForDomain(ctx context.Context, arg FindMatchingZoneForDomainParams) (DelegatedZone, error) {
	row := q.db.QueryRow(ctx, findMatchingZoneForDomain, arg.UserID, arg.Lower)
	var i DelegatedZone
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Zone,
		&i.Status,
		&i.VerificationToken,
		&i.WildcardCertSecret,
		&i.CertIssuedAt,
		&i.VerifiedAt,
		&i.DelegatedAt,
		&i.ExpiresAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findOverlappingZone = `-- name: FindOverlappingZone :one
SELECT id, user_id, zone, status, verification_token, wildcard_cert_secret, cert_issued_at, verified_at, delegated_at, expires_at, last_error, created_at, updated_at FROM delegated_zones
WHERE status != 'failed'
  AND (lower(zone) = lower($1)
       OR lower($1) LIKE '%.' || lower(zone)
       OR lower(zone) LIKE '%.' || lower($1))
LIMIT 1
`

func (q *Queries) FindOverlappingZone(ctx context.Context, lower string) (DelegatedZone, error) {
	row := q.db.QueryRow(ctx, findOverlappingZone, lower)
	var i DelegatedZone
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Zone,
		&i.Status,
		&i.VerificationToken,
		&i.WildcardCertSecret,
		&i.CertIssuedAt,
		&i.VerifiedAt,
		&i.DelegatedAt,
		&i.ExpiresAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getByID = `-- name: GetByID :one
SELECT id, user_id, zone, status, verification_token, wildcard_cert_secret, cert_issued_at, verified_at, delegated_at, expires_at, last_error, created_at, updated_at FROM delegated_zones WHERE id = $1
`

func (q *Queries) GetByID(ctx context.Context, id string) (DelegatedZone, error) {
	row := q.db.QueryRow(ctx, getByID, id)
	var i DelegatedZone
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Zone,
		&i.Status,
		&i.VerificationToken,
		&i.WildcardCertSecret,
		&i.CertIssuedAt,
		&i.VerifiedAt,
		&i.DelegatedAt,
		&i.ExpiresAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getByIDs = `-- name: GetByIDs :many
SELECT id, user_id, zone, status, verification_token, wildcard_cert_secret, cert_issued_at, verified_at, delegated_at, expires_at, last_error, created_at, updated_at FROM delegated_zones WHERE id = ANY($1::text[])
`

func (q *Queries) GetByIDs(ctx context.Context, dollar_1 []string) ([]DelegatedZone, error) {
	rows, err := q.db.Query(ctx, getByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DelegatedZone{}
	for rows.Next() {
		var i DelegatedZone
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Zone,
			&i.Status,
			&i.VerificationToken,
			&i.WildcardCertSecret,
			&i.CertIssuedAt,
			&i.VerifiedAt,
			&i.DelegatedAt,
			&i.ExpiresAt,
			&i.LastError,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getByZone = `-- name: GetByZone :one
SELECT id, user_id, zone, status, verification_token, wildcard_cert_secret, cert_issued_at, verified_at, delegated_at, expires_at, last_error, created_at, updated_at FROM delegated_zones WHERE lower(zone) = lower($1)
`

func (q *Queries) GetByZone(ctx context.Context, lower string) (DelegatedZone, error) {
	row := q.db.QueryRow(ctx, getByZone, lower)
	var i DelegatedZone
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Zone,
		&i.Status,
		&i.VerificationToken,
		&i.WildcardCertSecret,
		&i.CertIssuedAt,
		&i.VerifiedAt,
		&i.DelegatedAt,
		&i.ExpiresAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listByUserID = `-- name: ListByUserID :many
SELECT id, user_id, zone, status, verification_token, wildcard_cert_secret, cert_issued_at, verified_at, delegated_at, expires_at, last_error, created_at, updated_at FROM delegated_zones
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListByUserID(ctx context.Context, userID string) ([]DelegatedZone, error) {
	rows, err := q.db.Query(ctx, listByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DelegatedZone{}
	for rows.Next() {
		var i DelegatedZone
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Zone,
			&i.Status,
			&i.VerificationToken,
			&i.WildcardCertSecret,
			&i.CertIssuedAt,
			&i.VerifiedAt,
			&i.DelegatedAt,
			&i.ExpiresAt,
			&i.LastError,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateActivated = `-- name: UpdateActivated :one
UPDATE delegated_zones
SET status = 'active',
    wildcard_cert_secret = $2,
    cert_issued_at = NOW(),
    last_error = NULL,
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, zone, status, verification_token, wildcard_cert_secret, cert_issued_at, verified_at, delegated_at, expires_at, last_error, created_at, updated_at
`

type UpdateActivatedParams struct {
	ID                 string  `json:"id"`
	WildcardCertSecret *string `json:"wildcard_cert_secret"`
}

func (q *Queries) UpdateActivated(ctx context.Context, arg UpdateActivatedParams) (DelegatedZone, error) {
	row := q.db.QueryRow(ctx, updateActivated, arg.ID, arg.WildcardCertSecret)
	var i DelegatedZone
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Zone,
		&i.Status,
		&i.VerificationToken,
		&i.WildcardCertSecret,
		&i.CertIssuedAt,
		&i.VerifiedAt,
		&i.DelegatedAt,
		&i.ExpiresAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateError = `-- name: UpdateError :exec
UPDATE delegated_zones
SET last_error = $2,
    updated_at = NOW()
WHERE id = $1
`

type UpdateErrorParams struct {
	ID        string  `json:"id"`
	LastError *string `json:"last_error"`
}

func (q *Queries) UpdateError(ctx context.Context, arg UpdateErrorParams) error {
	_, err := q.db.Exec(ctx, updateError, arg.ID, arg.LastError)
	return err
}

const updateProvisioning = `-- name: UpdateProvisioning :one
UPDATE delegated_zones
SET status = 'provisioning',
    delegated_at = NOW(),
    last_error = NULL,
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, zone, status, verification_token, wildcard_cert_secret, cert_issued_at, verified_at, delegated_at, expires_at, last_error, created_at, updated_at
`

func (q *Queries) UpdateProvisioning(ctx context.Context, id string) (DelegatedZone, error) {
	row := q.db.QueryRow(ctx, updateProvisioning, id)
	var i DelegatedZone
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Zone,
		&i.Status,
		&i.VerificationToken,
		&i.WildcardCertSecret,
		&i.CertIssuedAt,
		&i.VerifiedAt,
		&i.DelegatedAt,
		&i.ExpiresAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateStatus = `-- name: UpdateStatus :one
UPDATE delegated_zones
SET status = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, zone, status, verification_token, wildcard_cert_secret, cert_issued_at, verified_at, delegated_at, expires_at, last_error, created_at, updated_at
`

type UpdateStatusParams struct {
	ID     string `json:"id"`
	Status string `json:"status"`
}

func (q *Queries) UpdateStatus(ctx context.Context, arg UpdateStatusParams) (DelegatedZone, error) {
	row := q.db.QueryRow(ctx, updateStatus, arg.ID, arg.Status)
	var i DelegatedZone
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Zone,
		&i.Status,
		&i.VerificationToken,
		&i.WildcardCertSecret,
		&i.CertIssuedAt,
		&i.VerifiedAt,
		&i.DelegatedAt,
		&i.ExpiresAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTXTVerified = `-- name: UpdateTXTVerified :one
UPDATE delegated_zones
SET status = 'pending_delegation',
    verified_at = NOW(),
    last_error = NULL,
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, zone, status, verification_token, wildcard_cert_secret, cert_issued_at, verified_at, delegated_at, expires_at, last_error, created_at, updated_at
`

func (q *Queries) UpdateTXTVerified(ctx context.Context, id string) (DelegatedZone, error) {
	row := q.db.QueryRow(ctx, updateTXTVerified, id)
	var i DelegatedZone
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Zone,
		&i.Status,
		&i.VerificationToken,
		&i.WildcardCertSecret,
		&i.CertIssuedAt,
		&i.VerifiedAt,
		&i.DelegatedAt,
		&i.ExpiresAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
