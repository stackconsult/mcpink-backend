// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: services.sql

package services

import (
	"context"
)

const countServicesByProjectID = `-- name: CountServicesByProjectID :one
SELECT COUNT(*) FROM services WHERE project_id = $1 AND is_deleted = false
`

func (q *Queries) CountServicesByProjectID(ctx context.Context, projectID string) (int64, error) {
	row := q.db.QueryRow(ctx, countServicesByProjectID, projectID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countServicesByUserID = `-- name: CountServicesByUserID :one
SELECT COUNT(*) FROM services WHERE user_id = $1 AND is_deleted = false
`

func (q *Queries) CountServicesByUserID(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRow(ctx, countServicesByUserID, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createService = `-- name: CreateService :one
INSERT INTO services (
    id, user_id, project_id, repo, branch, server_uuid, name, build_pack, port, env_vars, git_provider, build_config, memory, vcpus, cluster_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15
)
RETURNING id, user_id, project_id, repo, branch, git_provider, name, port, build_pack, env_vars, build_config, memory, vcpus, publish_directory, fqdn, custom_domain, server_uuid, current_deployment_id, is_deleted, created_at, updated_at, cluster_id
`

type CreateServiceParams struct {
	ID          string  `json:"id"`
	UserID      string  `json:"user_id"`
	ProjectID   string  `json:"project_id"`
	Repo        string  `json:"repo"`
	Branch      string  `json:"branch"`
	ServerUuid  string  `json:"server_uuid"`
	Name        *string `json:"name"`
	BuildPack   string  `json:"build_pack"`
	Port        string  `json:"port"`
	EnvVars     []byte  `json:"env_vars"`
	GitProvider string  `json:"git_provider"`
	BuildConfig []byte  `json:"build_config"`
	Memory      string  `json:"memory"`
	Vcpus       string  `json:"vcpus"`
	ClusterID   string  `json:"cluster_id"`
}

func (q *Queries) CreateService(ctx context.Context, arg CreateServiceParams) (Service, error) {
	row := q.db.QueryRow(ctx, createService,
		arg.ID,
		arg.UserID,
		arg.ProjectID,
		arg.Repo,
		arg.Branch,
		arg.ServerUuid,
		arg.Name,
		arg.BuildPack,
		arg.Port,
		arg.EnvVars,
		arg.GitProvider,
		arg.BuildConfig,
		arg.Memory,
		arg.Vcpus,
		arg.ClusterID,
	)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProjectID,
		&i.Repo,
		&i.Branch,
		&i.GitProvider,
		&i.Name,
		&i.Port,
		&i.BuildPack,
		&i.EnvVars,
		&i.BuildConfig,
		&i.Memory,
		&i.Vcpus,
		&i.PublishDirectory,
		&i.Fqdn,
		&i.CustomDomain,
		&i.ServerUuid,
		&i.CurrentDeploymentID,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClusterID,
	)
	return i, err
}

const deleteService = `-- name: DeleteService :exec
DELETE FROM services WHERE id = $1
`

func (q *Queries) DeleteService(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteService, id)
	return err
}

const getServiceByID = `-- name: GetServiceByID :one
SELECT id, user_id, project_id, repo, branch, git_provider, name, port, build_pack, env_vars, build_config, memory, vcpus, publish_directory, fqdn, custom_domain, server_uuid, current_deployment_id, is_deleted, created_at, updated_at, cluster_id FROM services WHERE id = $1 AND is_deleted = false
`

func (q *Queries) GetServiceByID(ctx context.Context, id string) (Service, error) {
	row := q.db.QueryRow(ctx, getServiceByID, id)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProjectID,
		&i.Repo,
		&i.Branch,
		&i.GitProvider,
		&i.Name,
		&i.Port,
		&i.BuildPack,
		&i.EnvVars,
		&i.BuildConfig,
		&i.Memory,
		&i.Vcpus,
		&i.PublishDirectory,
		&i.Fqdn,
		&i.CustomDomain,
		&i.ServerUuid,
		&i.CurrentDeploymentID,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClusterID,
	)
	return i, err
}

const getServiceByNameAndProject = `-- name: GetServiceByNameAndProject :one
SELECT id, user_id, project_id, repo, branch, git_provider, name, port, build_pack, env_vars, build_config, memory, vcpus, publish_directory, fqdn, custom_domain, server_uuid, current_deployment_id, is_deleted, created_at, updated_at, cluster_id FROM services
WHERE name = $1 AND project_id = $2 AND is_deleted = false
`

type GetServiceByNameAndProjectParams struct {
	Name      *string `json:"name"`
	ProjectID string  `json:"project_id"`
}

func (q *Queries) GetServiceByNameAndProject(ctx context.Context, arg GetServiceByNameAndProjectParams) (Service, error) {
	row := q.db.QueryRow(ctx, getServiceByNameAndProject, arg.Name, arg.ProjectID)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProjectID,
		&i.Repo,
		&i.Branch,
		&i.GitProvider,
		&i.Name,
		&i.Port,
		&i.BuildPack,
		&i.EnvVars,
		&i.BuildConfig,
		&i.Memory,
		&i.Vcpus,
		&i.PublishDirectory,
		&i.Fqdn,
		&i.CustomDomain,
		&i.ServerUuid,
		&i.CurrentDeploymentID,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClusterID,
	)
	return i, err
}

const getServiceByNameAndUserProject = `-- name: GetServiceByNameAndUserProject :one
SELECT a.id, a.user_id, a.project_id, a.repo, a.branch, a.git_provider, a.name, a.port, a.build_pack, a.env_vars, a.build_config, a.memory, a.vcpus, a.publish_directory, a.fqdn, a.custom_domain, a.server_uuid, a.current_deployment_id, a.is_deleted, a.created_at, a.updated_at, a.cluster_id FROM services a
JOIN projects p ON a.project_id = p.id
WHERE a.name = $1
  AND p.user_id = $2
  AND (p.ref = $3 OR ($3 = 'default' AND p.is_default = true))
  AND a.is_deleted = false
ORDER BY a.updated_at DESC, a.created_at DESC, a.id DESC
LIMIT 1
`

type GetServiceByNameAndUserProjectParams struct {
	Name   *string `json:"name"`
	UserID string  `json:"user_id"`
	Ref    string  `json:"ref"`
}

func (q *Queries) GetServiceByNameAndUserProject(ctx context.Context, arg GetServiceByNameAndUserProjectParams) (Service, error) {
	row := q.db.QueryRow(ctx, getServiceByNameAndUserProject, arg.Name, arg.UserID, arg.Ref)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProjectID,
		&i.Repo,
		&i.Branch,
		&i.GitProvider,
		&i.Name,
		&i.Port,
		&i.BuildPack,
		&i.EnvVars,
		&i.BuildConfig,
		&i.Memory,
		&i.Vcpus,
		&i.PublishDirectory,
		&i.Fqdn,
		&i.CustomDomain,
		&i.ServerUuid,
		&i.CurrentDeploymentID,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClusterID,
	)
	return i, err
}

const getServicesByRepoBranch = `-- name: GetServicesByRepoBranch :many
SELECT id, user_id, project_id, repo, branch, git_provider, name, port, build_pack, env_vars, build_config, memory, vcpus, publish_directory, fqdn, custom_domain, server_uuid, current_deployment_id, is_deleted, created_at, updated_at, cluster_id FROM services
WHERE repo = $1 AND branch = $2 AND is_deleted = false
`

type GetServicesByRepoBranchParams struct {
	Repo   string `json:"repo"`
	Branch string `json:"branch"`
}

func (q *Queries) GetServicesByRepoBranch(ctx context.Context, arg GetServicesByRepoBranchParams) ([]Service, error) {
	rows, err := q.db.Query(ctx, getServicesByRepoBranch, arg.Repo, arg.Branch)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Service{}
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProjectID,
			&i.Repo,
			&i.Branch,
			&i.GitProvider,
			&i.Name,
			&i.Port,
			&i.BuildPack,
			&i.EnvVars,
			&i.BuildConfig,
			&i.Memory,
			&i.Vcpus,
			&i.PublishDirectory,
			&i.Fqdn,
			&i.CustomDomain,
			&i.ServerUuid,
			&i.CurrentDeploymentID,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClusterID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServicesByRepoBranchProvider = `-- name: GetServicesByRepoBranchProvider :many
SELECT id, user_id, project_id, repo, branch, git_provider, name, port, build_pack, env_vars, build_config, memory, vcpus, publish_directory, fqdn, custom_domain, server_uuid, current_deployment_id, is_deleted, created_at, updated_at, cluster_id FROM services
WHERE repo = $1 AND branch = $2 AND git_provider = $3 AND is_deleted = false
`

type GetServicesByRepoBranchProviderParams struct {
	Repo        string `json:"repo"`
	Branch      string `json:"branch"`
	GitProvider string `json:"git_provider"`
}

func (q *Queries) GetServicesByRepoBranchProvider(ctx context.Context, arg GetServicesByRepoBranchProviderParams) ([]Service, error) {
	rows, err := q.db.Query(ctx, getServicesByRepoBranchProvider, arg.Repo, arg.Branch, arg.GitProvider)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Service{}
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProjectID,
			&i.Repo,
			&i.Branch,
			&i.GitProvider,
			&i.Name,
			&i.Port,
			&i.BuildPack,
			&i.EnvVars,
			&i.BuildConfig,
			&i.Memory,
			&i.Vcpus,
			&i.PublishDirectory,
			&i.Fqdn,
			&i.CustomDomain,
			&i.ServerUuid,
			&i.CurrentDeploymentID,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClusterID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServicesByProjectID = `-- name: ListServicesByProjectID :many
SELECT id, user_id, project_id, repo, branch, git_provider, name, port, build_pack, env_vars, build_config, memory, vcpus, publish_directory, fqdn, custom_domain, server_uuid, current_deployment_id, is_deleted, created_at, updated_at, cluster_id FROM services
WHERE project_id = $1 AND is_deleted = false
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListServicesByProjectIDParams struct {
	ProjectID string `json:"project_id"`
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
}

func (q *Queries) ListServicesByProjectID(ctx context.Context, arg ListServicesByProjectIDParams) ([]Service, error) {
	rows, err := q.db.Query(ctx, listServicesByProjectID, arg.ProjectID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Service{}
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProjectID,
			&i.Repo,
			&i.Branch,
			&i.GitProvider,
			&i.Name,
			&i.Port,
			&i.BuildPack,
			&i.EnvVars,
			&i.BuildConfig,
			&i.Memory,
			&i.Vcpus,
			&i.PublishDirectory,
			&i.Fqdn,
			&i.CustomDomain,
			&i.ServerUuid,
			&i.CurrentDeploymentID,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClusterID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServicesByUserID = `-- name: ListServicesByUserID :many
SELECT id, user_id, project_id, repo, branch, git_provider, name, port, build_pack, env_vars, build_config, memory, vcpus, publish_directory, fqdn, custom_domain, server_uuid, current_deployment_id, is_deleted, created_at, updated_at, cluster_id FROM services
WHERE user_id = $1 AND is_deleted = false
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListServicesByUserIDParams struct {
	UserID string `json:"user_id"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListServicesByUserID(ctx context.Context, arg ListServicesByUserIDParams) ([]Service, error) {
	rows, err := q.db.Query(ctx, listServicesByUserID, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Service{}
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProjectID,
			&i.Repo,
			&i.Branch,
			&i.GitProvider,
			&i.Name,
			&i.Port,
			&i.BuildPack,
			&i.EnvVars,
			&i.BuildConfig,
			&i.Memory,
			&i.Vcpus,
			&i.PublishDirectory,
			&i.Fqdn,
			&i.CustomDomain,
			&i.ServerUuid,
			&i.CurrentDeploymentID,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClusterID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setCurrentDeploymentID = `-- name: SetCurrentDeploymentID :exec
UPDATE services
SET current_deployment_id = $2, updated_at = NOW()
WHERE id = $1 AND is_deleted = false
`

type SetCurrentDeploymentIDParams struct {
	ID                  string  `json:"id"`
	CurrentDeploymentID *string `json:"current_deployment_id"`
}

func (q *Queries) SetCurrentDeploymentID(ctx context.Context, arg SetCurrentDeploymentIDParams) error {
	_, err := q.db.Exec(ctx, setCurrentDeploymentID, arg.ID, arg.CurrentDeploymentID)
	return err
}

const setServiceFQDN = `-- name: SetServiceFQDN :exec
UPDATE services
SET fqdn = $2, updated_at = NOW()
WHERE id = $1 AND is_deleted = false
`

type SetServiceFQDNParams struct {
	ID   string  `json:"id"`
	Fqdn *string `json:"fqdn"`
}

func (q *Queries) SetServiceFQDN(ctx context.Context, arg SetServiceFQDNParams) error {
	_, err := q.db.Exec(ctx, setServiceFQDN, arg.ID, arg.Fqdn)
	return err
}

const softDeleteService = `-- name: SoftDeleteService :one
UPDATE services
SET is_deleted = true, updated_at = NOW()
WHERE id = $1 AND is_deleted = false
RETURNING id, user_id, project_id, repo, branch, git_provider, name, port, build_pack, env_vars, build_config, memory, vcpus, publish_directory, fqdn, custom_domain, server_uuid, current_deployment_id, is_deleted, created_at, updated_at, cluster_id
`

func (q *Queries) SoftDeleteService(ctx context.Context, id string) (Service, error) {
	row := q.db.QueryRow(ctx, softDeleteService, id)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProjectID,
		&i.Repo,
		&i.Branch,
		&i.GitProvider,
		&i.Name,
		&i.Port,
		&i.BuildPack,
		&i.EnvVars,
		&i.BuildConfig,
		&i.Memory,
		&i.Vcpus,
		&i.PublishDirectory,
		&i.Fqdn,
		&i.CustomDomain,
		&i.ServerUuid,
		&i.CurrentDeploymentID,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClusterID,
	)
	return i, err
}
