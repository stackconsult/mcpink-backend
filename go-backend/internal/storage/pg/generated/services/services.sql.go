// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: services.sql

package services

import (
	"context"
)

const clearServiceBuildProgress = `-- name: ClearServiceBuildProgress :exec
UPDATE services
SET build_progress = NULL, updated_at = NOW()
WHERE id = $1 AND is_deleted = false
`

func (q *Queries) ClearServiceBuildProgress(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, clearServiceBuildProgress, id)
	return err
}

const countServicesByProjectID = `-- name: CountServicesByProjectID :one
SELECT COUNT(*) FROM services WHERE project_id = $1 AND is_deleted = false
`

func (q *Queries) CountServicesByProjectID(ctx context.Context, projectID string) (int64, error) {
	row := q.db.QueryRow(ctx, countServicesByProjectID, projectID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countServicesByUserID = `-- name: CountServicesByUserID :one
SELECT COUNT(*) FROM services WHERE user_id = $1 AND is_deleted = false
`

func (q *Queries) CountServicesByUserID(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRow(ctx, countServicesByUserID, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createService = `-- name: CreateService :one
INSERT INTO services (
    id, user_id, project_id, repo, branch, server_uuid, name, build_pack, port, env_vars, workflow_id, workflow_run_id, build_status, git_provider, build_config, memory, cpu
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, 'queued', $13, $14, $15, $16
)
RETURNING id, user_id, build_status, runtime_status, error_message, repo, branch, server_uuid, name, build_pack, port, env_vars, fqdn, workflow_id, workflow_run_id, created_at, updated_at, project_id, commit_hash, is_deleted, git_provider, custom_domain, build_progress, memory, cpu, build_config
`

type CreateServiceParams struct {
	ID            string  `json:"id"`
	UserID        string  `json:"user_id"`
	ProjectID     string  `json:"project_id"`
	Repo          string  `json:"repo"`
	Branch        string  `json:"branch"`
	ServerUuid    string  `json:"server_uuid"`
	Name          *string `json:"name"`
	BuildPack     string  `json:"build_pack"`
	Port          string  `json:"port"`
	EnvVars       []byte  `json:"env_vars"`
	WorkflowID    string  `json:"workflow_id"`
	WorkflowRunID *string `json:"workflow_run_id"`
	GitProvider   string  `json:"git_provider"`
	BuildConfig   []byte  `json:"build_config"`
	Memory        string  `json:"memory"`
	Cpu           string  `json:"cpu"`
}

func (q *Queries) CreateService(ctx context.Context, arg CreateServiceParams) (Service, error) {
	row := q.db.QueryRow(ctx, createService,
		arg.ID,
		arg.UserID,
		arg.ProjectID,
		arg.Repo,
		arg.Branch,
		arg.ServerUuid,
		arg.Name,
		arg.BuildPack,
		arg.Port,
		arg.EnvVars,
		arg.WorkflowID,
		arg.WorkflowRunID,
		arg.GitProvider,
		arg.BuildConfig,
		arg.Memory,
		arg.Cpu,
	)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BuildStatus,
		&i.RuntimeStatus,
		&i.ErrorMessage,
		&i.Repo,
		&i.Branch,
		&i.ServerUuid,
		&i.Name,
		&i.BuildPack,
		&i.Port,
		&i.EnvVars,
		&i.Fqdn,
		&i.WorkflowID,
		&i.WorkflowRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectID,
		&i.CommitHash,
		&i.IsDeleted,
		&i.GitProvider,
		&i.CustomDomain,
		&i.BuildProgress,
		&i.Memory,
		&i.Cpu,
		&i.BuildConfig,
	)
	return i, err
}

const deleteService = `-- name: DeleteService :exec
DELETE FROM services WHERE id = $1
`

func (q *Queries) DeleteService(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteService, id)
	return err
}

const getServiceByID = `-- name: GetServiceByID :one
SELECT id, user_id, build_status, runtime_status, error_message, repo, branch, server_uuid, name, build_pack, port, env_vars, fqdn, workflow_id, workflow_run_id, created_at, updated_at, project_id, commit_hash, is_deleted, git_provider, custom_domain, build_progress, memory, cpu, build_config FROM services WHERE id = $1 AND is_deleted = false
`

func (q *Queries) GetServiceByID(ctx context.Context, id string) (Service, error) {
	row := q.db.QueryRow(ctx, getServiceByID, id)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BuildStatus,
		&i.RuntimeStatus,
		&i.ErrorMessage,
		&i.Repo,
		&i.Branch,
		&i.ServerUuid,
		&i.Name,
		&i.BuildPack,
		&i.Port,
		&i.EnvVars,
		&i.Fqdn,
		&i.WorkflowID,
		&i.WorkflowRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectID,
		&i.CommitHash,
		&i.IsDeleted,
		&i.GitProvider,
		&i.CustomDomain,
		&i.BuildProgress,
		&i.Memory,
		&i.Cpu,
		&i.BuildConfig,
	)
	return i, err
}

const getServiceByNameAndProject = `-- name: GetServiceByNameAndProject :one
SELECT id, user_id, build_status, runtime_status, error_message, repo, branch, server_uuid, name, build_pack, port, env_vars, fqdn, workflow_id, workflow_run_id, created_at, updated_at, project_id, commit_hash, is_deleted, git_provider, custom_domain, build_progress, memory, cpu, build_config FROM services
WHERE name = $1 AND project_id = $2 AND is_deleted = false
`

type GetServiceByNameAndProjectParams struct {
	Name      *string `json:"name"`
	ProjectID string  `json:"project_id"`
}

func (q *Queries) GetServiceByNameAndProject(ctx context.Context, arg GetServiceByNameAndProjectParams) (Service, error) {
	row := q.db.QueryRow(ctx, getServiceByNameAndProject, arg.Name, arg.ProjectID)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BuildStatus,
		&i.RuntimeStatus,
		&i.ErrorMessage,
		&i.Repo,
		&i.Branch,
		&i.ServerUuid,
		&i.Name,
		&i.BuildPack,
		&i.Port,
		&i.EnvVars,
		&i.Fqdn,
		&i.WorkflowID,
		&i.WorkflowRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectID,
		&i.CommitHash,
		&i.IsDeleted,
		&i.GitProvider,
		&i.CustomDomain,
		&i.BuildProgress,
		&i.Memory,
		&i.Cpu,
		&i.BuildConfig,
	)
	return i, err
}

const getServiceByNameAndUserProject = `-- name: GetServiceByNameAndUserProject :one
SELECT a.id, a.user_id, a.build_status, a.runtime_status, a.error_message, a.repo, a.branch, a.server_uuid, a.name, a.build_pack, a.port, a.env_vars, a.fqdn, a.workflow_id, a.workflow_run_id, a.created_at, a.updated_at, a.project_id, a.commit_hash, a.is_deleted, a.git_provider, a.custom_domain, a.build_progress, a.memory, a.cpu, a.build_config FROM services a
JOIN projects p ON a.project_id = p.id
WHERE a.name = $1
  AND p.user_id = $2
  AND (p.ref = $3 OR ($3 = 'default' AND p.is_default = true))
  AND a.is_deleted = false
ORDER BY a.updated_at DESC, a.created_at DESC, a.id DESC
LIMIT 1
`

type GetServiceByNameAndUserProjectParams struct {
	Name   *string `json:"name"`
	UserID string  `json:"user_id"`
	Ref    string  `json:"ref"`
}

func (q *Queries) GetServiceByNameAndUserProject(ctx context.Context, arg GetServiceByNameAndUserProjectParams) (Service, error) {
	row := q.db.QueryRow(ctx, getServiceByNameAndUserProject, arg.Name, arg.UserID, arg.Ref)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BuildStatus,
		&i.RuntimeStatus,
		&i.ErrorMessage,
		&i.Repo,
		&i.Branch,
		&i.ServerUuid,
		&i.Name,
		&i.BuildPack,
		&i.Port,
		&i.EnvVars,
		&i.Fqdn,
		&i.WorkflowID,
		&i.WorkflowRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectID,
		&i.CommitHash,
		&i.IsDeleted,
		&i.GitProvider,
		&i.CustomDomain,
		&i.BuildProgress,
		&i.Memory,
		&i.Cpu,
		&i.BuildConfig,
	)
	return i, err
}

const getServiceByWorkflowID = `-- name: GetServiceByWorkflowID :one
SELECT id, user_id, build_status, runtime_status, error_message, repo, branch, server_uuid, name, build_pack, port, env_vars, fqdn, workflow_id, workflow_run_id, created_at, updated_at, project_id, commit_hash, is_deleted, git_provider, custom_domain, build_progress, memory, cpu, build_config FROM services WHERE workflow_id = $1 AND is_deleted = false
`

func (q *Queries) GetServiceByWorkflowID(ctx context.Context, workflowID string) (Service, error) {
	row := q.db.QueryRow(ctx, getServiceByWorkflowID, workflowID)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BuildStatus,
		&i.RuntimeStatus,
		&i.ErrorMessage,
		&i.Repo,
		&i.Branch,
		&i.ServerUuid,
		&i.Name,
		&i.BuildPack,
		&i.Port,
		&i.EnvVars,
		&i.Fqdn,
		&i.WorkflowID,
		&i.WorkflowRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectID,
		&i.CommitHash,
		&i.IsDeleted,
		&i.GitProvider,
		&i.CustomDomain,
		&i.BuildProgress,
		&i.Memory,
		&i.Cpu,
		&i.BuildConfig,
	)
	return i, err
}

const getServicesByRepoBranch = `-- name: GetServicesByRepoBranch :many
SELECT id, user_id, build_status, runtime_status, error_message, repo, branch, server_uuid, name, build_pack, port, env_vars, fqdn, workflow_id, workflow_run_id, created_at, updated_at, project_id, commit_hash, is_deleted, git_provider, custom_domain, build_progress, memory, cpu, build_config FROM services
WHERE repo = $1 AND branch = $2 AND is_deleted = false
`

type GetServicesByRepoBranchParams struct {
	Repo   string `json:"repo"`
	Branch string `json:"branch"`
}

func (q *Queries) GetServicesByRepoBranch(ctx context.Context, arg GetServicesByRepoBranchParams) ([]Service, error) {
	rows, err := q.db.Query(ctx, getServicesByRepoBranch, arg.Repo, arg.Branch)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Service{}
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BuildStatus,
			&i.RuntimeStatus,
			&i.ErrorMessage,
			&i.Repo,
			&i.Branch,
			&i.ServerUuid,
			&i.Name,
			&i.BuildPack,
			&i.Port,
			&i.EnvVars,
			&i.Fqdn,
			&i.WorkflowID,
			&i.WorkflowRunID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectID,
			&i.CommitHash,
			&i.IsDeleted,
			&i.GitProvider,
			&i.CustomDomain,
			&i.BuildProgress,
			&i.Memory,
			&i.Cpu,
			&i.BuildConfig,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServicesByRepoBranchProvider = `-- name: GetServicesByRepoBranchProvider :many
SELECT id, user_id, build_status, runtime_status, error_message, repo, branch, server_uuid, name, build_pack, port, env_vars, fqdn, workflow_id, workflow_run_id, created_at, updated_at, project_id, commit_hash, is_deleted, git_provider, custom_domain, build_progress, memory, cpu, build_config FROM services
WHERE repo = $1 AND branch = $2 AND git_provider = $3 AND is_deleted = false
`

type GetServicesByRepoBranchProviderParams struct {
	Repo        string `json:"repo"`
	Branch      string `json:"branch"`
	GitProvider string `json:"git_provider"`
}

func (q *Queries) GetServicesByRepoBranchProvider(ctx context.Context, arg GetServicesByRepoBranchProviderParams) ([]Service, error) {
	rows, err := q.db.Query(ctx, getServicesByRepoBranchProvider, arg.Repo, arg.Branch, arg.GitProvider)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Service{}
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BuildStatus,
			&i.RuntimeStatus,
			&i.ErrorMessage,
			&i.Repo,
			&i.Branch,
			&i.ServerUuid,
			&i.Name,
			&i.BuildPack,
			&i.Port,
			&i.EnvVars,
			&i.Fqdn,
			&i.WorkflowID,
			&i.WorkflowRunID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectID,
			&i.CommitHash,
			&i.IsDeleted,
			&i.GitProvider,
			&i.CustomDomain,
			&i.BuildProgress,
			&i.Memory,
			&i.Cpu,
			&i.BuildConfig,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServicesByProjectID = `-- name: ListServicesByProjectID :many
SELECT id, user_id, build_status, runtime_status, error_message, repo, branch, server_uuid, name, build_pack, port, env_vars, fqdn, workflow_id, workflow_run_id, created_at, updated_at, project_id, commit_hash, is_deleted, git_provider, custom_domain, build_progress, memory, cpu, build_config FROM services
WHERE project_id = $1 AND is_deleted = false
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListServicesByProjectIDParams struct {
	ProjectID string `json:"project_id"`
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
}

func (q *Queries) ListServicesByProjectID(ctx context.Context, arg ListServicesByProjectIDParams) ([]Service, error) {
	rows, err := q.db.Query(ctx, listServicesByProjectID, arg.ProjectID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Service{}
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BuildStatus,
			&i.RuntimeStatus,
			&i.ErrorMessage,
			&i.Repo,
			&i.Branch,
			&i.ServerUuid,
			&i.Name,
			&i.BuildPack,
			&i.Port,
			&i.EnvVars,
			&i.Fqdn,
			&i.WorkflowID,
			&i.WorkflowRunID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectID,
			&i.CommitHash,
			&i.IsDeleted,
			&i.GitProvider,
			&i.CustomDomain,
			&i.BuildProgress,
			&i.Memory,
			&i.Cpu,
			&i.BuildConfig,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServicesByUserID = `-- name: ListServicesByUserID :many
SELECT id, user_id, build_status, runtime_status, error_message, repo, branch, server_uuid, name, build_pack, port, env_vars, fqdn, workflow_id, workflow_run_id, created_at, updated_at, project_id, commit_hash, is_deleted, git_provider, custom_domain, build_progress, memory, cpu, build_config FROM services
WHERE user_id = $1 AND is_deleted = false
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListServicesByUserIDParams struct {
	UserID string `json:"user_id"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListServicesByUserID(ctx context.Context, arg ListServicesByUserIDParams) ([]Service, error) {
	rows, err := q.db.Query(ctx, listServicesByUserID, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Service{}
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BuildStatus,
			&i.RuntimeStatus,
			&i.ErrorMessage,
			&i.Repo,
			&i.Branch,
			&i.ServerUuid,
			&i.Name,
			&i.BuildPack,
			&i.Port,
			&i.EnvVars,
			&i.Fqdn,
			&i.WorkflowID,
			&i.WorkflowRunID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectID,
			&i.CommitHash,
			&i.IsDeleted,
			&i.GitProvider,
			&i.CustomDomain,
			&i.BuildProgress,
			&i.Memory,
			&i.Cpu,
			&i.BuildConfig,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteService = `-- name: SoftDeleteService :one
UPDATE services
SET is_deleted = true, updated_at = NOW()
WHERE id = $1 AND is_deleted = false
RETURNING id, user_id, build_status, runtime_status, error_message, repo, branch, server_uuid, name, build_pack, port, env_vars, fqdn, workflow_id, workflow_run_id, created_at, updated_at, project_id, commit_hash, is_deleted, git_provider, custom_domain, build_progress, memory, cpu, build_config
`

func (q *Queries) SoftDeleteService(ctx context.Context, id string) (Service, error) {
	row := q.db.QueryRow(ctx, softDeleteService, id)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BuildStatus,
		&i.RuntimeStatus,
		&i.ErrorMessage,
		&i.Repo,
		&i.Branch,
		&i.ServerUuid,
		&i.Name,
		&i.BuildPack,
		&i.Port,
		&i.EnvVars,
		&i.Fqdn,
		&i.WorkflowID,
		&i.WorkflowRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectID,
		&i.CommitHash,
		&i.IsDeleted,
		&i.GitProvider,
		&i.CustomDomain,
		&i.BuildProgress,
		&i.Memory,
		&i.Cpu,
		&i.BuildConfig,
	)
	return i, err
}

const updateBuildStatus = `-- name: UpdateBuildStatus :one
UPDATE services
SET build_status = $2, updated_at = NOW()
WHERE id = $1 AND is_deleted = false
RETURNING id, user_id, build_status, runtime_status, error_message, repo, branch, server_uuid, name, build_pack, port, env_vars, fqdn, workflow_id, workflow_run_id, created_at, updated_at, project_id, commit_hash, is_deleted, git_provider, custom_domain, build_progress, memory, cpu, build_config
`

type UpdateBuildStatusParams struct {
	ID          string `json:"id"`
	BuildStatus string `json:"build_status"`
}

func (q *Queries) UpdateBuildStatus(ctx context.Context, arg UpdateBuildStatusParams) (Service, error) {
	row := q.db.QueryRow(ctx, updateBuildStatus, arg.ID, arg.BuildStatus)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BuildStatus,
		&i.RuntimeStatus,
		&i.ErrorMessage,
		&i.Repo,
		&i.Branch,
		&i.ServerUuid,
		&i.Name,
		&i.BuildPack,
		&i.Port,
		&i.EnvVars,
		&i.Fqdn,
		&i.WorkflowID,
		&i.WorkflowRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectID,
		&i.CommitHash,
		&i.IsDeleted,
		&i.GitProvider,
		&i.CustomDomain,
		&i.BuildProgress,
		&i.Memory,
		&i.Cpu,
		&i.BuildConfig,
	)
	return i, err
}

const updateRuntimeStatus = `-- name: UpdateRuntimeStatus :one
UPDATE services
SET runtime_status = $2, updated_at = NOW()
WHERE id = $1 AND is_deleted = false
RETURNING id, user_id, build_status, runtime_status, error_message, repo, branch, server_uuid, name, build_pack, port, env_vars, fqdn, workflow_id, workflow_run_id, created_at, updated_at, project_id, commit_hash, is_deleted, git_provider, custom_domain, build_progress, memory, cpu, build_config
`

type UpdateRuntimeStatusParams struct {
	ID            string  `json:"id"`
	RuntimeStatus *string `json:"runtime_status"`
}

func (q *Queries) UpdateRuntimeStatus(ctx context.Context, arg UpdateRuntimeStatusParams) (Service, error) {
	row := q.db.QueryRow(ctx, updateRuntimeStatus, arg.ID, arg.RuntimeStatus)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BuildStatus,
		&i.RuntimeStatus,
		&i.ErrorMessage,
		&i.Repo,
		&i.Branch,
		&i.ServerUuid,
		&i.Name,
		&i.BuildPack,
		&i.Port,
		&i.EnvVars,
		&i.Fqdn,
		&i.WorkflowID,
		&i.WorkflowRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectID,
		&i.CommitHash,
		&i.IsDeleted,
		&i.GitProvider,
		&i.CustomDomain,
		&i.BuildProgress,
		&i.Memory,
		&i.Cpu,
		&i.BuildConfig,
	)
	return i, err
}

const updateServiceBuildProgress = `-- name: UpdateServiceBuildProgress :exec
UPDATE services
SET build_progress = $2, updated_at = NOW()
WHERE id = $1 AND is_deleted = false
`

type UpdateServiceBuildProgressParams struct {
	ID            string `json:"id"`
	BuildProgress []byte `json:"build_progress"`
}

func (q *Queries) UpdateServiceBuildProgress(ctx context.Context, arg UpdateServiceBuildProgressParams) error {
	_, err := q.db.Exec(ctx, updateServiceBuildProgress, arg.ID, arg.BuildProgress)
	return err
}

const updateServiceFailed = `-- name: UpdateServiceFailed :one
UPDATE services
SET build_status = 'failed', error_message = $2, updated_at = NOW()
WHERE id = $1 AND is_deleted = false
RETURNING id, user_id, build_status, runtime_status, error_message, repo, branch, server_uuid, name, build_pack, port, env_vars, fqdn, workflow_id, workflow_run_id, created_at, updated_at, project_id, commit_hash, is_deleted, git_provider, custom_domain, build_progress, memory, cpu, build_config
`

type UpdateServiceFailedParams struct {
	ID           string  `json:"id"`
	ErrorMessage *string `json:"error_message"`
}

func (q *Queries) UpdateServiceFailed(ctx context.Context, arg UpdateServiceFailedParams) (Service, error) {
	row := q.db.QueryRow(ctx, updateServiceFailed, arg.ID, arg.ErrorMessage)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BuildStatus,
		&i.RuntimeStatus,
		&i.ErrorMessage,
		&i.Repo,
		&i.Branch,
		&i.ServerUuid,
		&i.Name,
		&i.BuildPack,
		&i.Port,
		&i.EnvVars,
		&i.Fqdn,
		&i.WorkflowID,
		&i.WorkflowRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectID,
		&i.CommitHash,
		&i.IsDeleted,
		&i.GitProvider,
		&i.CustomDomain,
		&i.BuildProgress,
		&i.Memory,
		&i.Cpu,
		&i.BuildConfig,
	)
	return i, err
}

const updateServiceRedeploying = `-- name: UpdateServiceRedeploying :one
UPDATE services
SET build_status = 'building', updated_at = NOW()
WHERE id = $1 AND is_deleted = false
RETURNING id, user_id, build_status, runtime_status, error_message, repo, branch, server_uuid, name, build_pack, port, env_vars, fqdn, workflow_id, workflow_run_id, created_at, updated_at, project_id, commit_hash, is_deleted, git_provider, custom_domain, build_progress, memory, cpu, build_config
`

func (q *Queries) UpdateServiceRedeploying(ctx context.Context, id string) (Service, error) {
	row := q.db.QueryRow(ctx, updateServiceRedeploying, id)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BuildStatus,
		&i.RuntimeStatus,
		&i.ErrorMessage,
		&i.Repo,
		&i.Branch,
		&i.ServerUuid,
		&i.Name,
		&i.BuildPack,
		&i.Port,
		&i.EnvVars,
		&i.Fqdn,
		&i.WorkflowID,
		&i.WorkflowRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectID,
		&i.CommitHash,
		&i.IsDeleted,
		&i.GitProvider,
		&i.CustomDomain,
		&i.BuildProgress,
		&i.Memory,
		&i.Cpu,
		&i.BuildConfig,
	)
	return i, err
}

const updateServiceRunning = `-- name: UpdateServiceRunning :one
UPDATE services
SET build_status = 'success', runtime_status = 'running', fqdn = $2, commit_hash = $3, updated_at = NOW()
WHERE id = $1 AND is_deleted = false
RETURNING id, user_id, build_status, runtime_status, error_message, repo, branch, server_uuid, name, build_pack, port, env_vars, fqdn, workflow_id, workflow_run_id, created_at, updated_at, project_id, commit_hash, is_deleted, git_provider, custom_domain, build_progress, memory, cpu, build_config
`

type UpdateServiceRunningParams struct {
	ID         string  `json:"id"`
	Fqdn       *string `json:"fqdn"`
	CommitHash *string `json:"commit_hash"`
}

func (q *Queries) UpdateServiceRunning(ctx context.Context, arg UpdateServiceRunningParams) (Service, error) {
	row := q.db.QueryRow(ctx, updateServiceRunning, arg.ID, arg.Fqdn, arg.CommitHash)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BuildStatus,
		&i.RuntimeStatus,
		&i.ErrorMessage,
		&i.Repo,
		&i.Branch,
		&i.ServerUuid,
		&i.Name,
		&i.BuildPack,
		&i.Port,
		&i.EnvVars,
		&i.Fqdn,
		&i.WorkflowID,
		&i.WorkflowRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectID,
		&i.CommitHash,
		&i.IsDeleted,
		&i.GitProvider,
		&i.CustomDomain,
		&i.BuildProgress,
		&i.Memory,
		&i.Cpu,
		&i.BuildConfig,
	)
	return i, err
}

const updateWorkflowRunID = `-- name: UpdateWorkflowRunID :exec
UPDATE services
SET workflow_run_id = $2, updated_at = NOW()
WHERE id = $1 AND is_deleted = false
`

type UpdateWorkflowRunIDParams struct {
	ID            string  `json:"id"`
	WorkflowRunID *string `json:"workflow_run_id"`
}

func (q *Queries) UpdateWorkflowRunID(ctx context.Context, arg UpdateWorkflowRunIDParams) error {
	_, err := q.db.Exec(ctx, updateWorkflowRunID, arg.ID, arg.WorkflowRunID)
	return err
}
