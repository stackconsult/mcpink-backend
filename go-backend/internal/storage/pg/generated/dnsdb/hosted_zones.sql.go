// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: hosted_zones.sql

package dnsdb

import (
	"context"
)

const createHostedZone = `-- name: CreateHostedZone :one
INSERT INTO hosted_zones (id, user_id, zone, verification_token)
VALUES ($1, $2, $3, $4) RETURNING id, user_id, zone, status, verification_token, wildcard_cert_secret, cert_issued_at, verified_at, delegated_at, expires_at, last_error, created_at, updated_at
`

type CreateHostedZoneParams struct {
	ID                string `json:"id"`
	UserID            string `json:"user_id"`
	Zone              string `json:"zone"`
	VerificationToken string `json:"verification_token"`
}

func (q *Queries) CreateHostedZone(ctx context.Context, arg CreateHostedZoneParams) (HostedZone, error) {
	row := q.db.QueryRow(ctx, createHostedZone,
		arg.ID,
		arg.UserID,
		arg.Zone,
		arg.VerificationToken,
	)
	var i HostedZone
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Zone,
		&i.Status,
		&i.VerificationToken,
		&i.WildcardCertSecret,
		&i.CertIssuedAt,
		&i.VerifiedAt,
		&i.DelegatedAt,
		&i.ExpiresAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteHostedZone = `-- name: DeleteHostedZone :exec
DELETE FROM hosted_zones WHERE id = $1
`

func (q *Queries) DeleteHostedZone(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteHostedZone, id)
	return err
}

const findMatchingHostedZoneForDomain = `-- name: FindMatchingHostedZoneForDomain :one
SELECT id, user_id, zone, status, verification_token, wildcard_cert_secret, cert_issued_at, verified_at, delegated_at, expires_at, last_error, created_at, updated_at FROM hosted_zones
WHERE user_id = $1
  AND status = 'active'
  AND lower($2) LIKE '%.' || lower(zone)
ORDER BY length(zone) DESC
LIMIT 1
`

type FindMatchingHostedZoneForDomainParams struct {
	UserID string `json:"user_id"`
	Lower  string `json:"lower"`
}

func (q *Queries) FindMatchingHostedZoneForDomain(ctx context.Context, arg FindMatchingHostedZoneForDomainParams) (HostedZone, error) {
	row := q.db.QueryRow(ctx, findMatchingHostedZoneForDomain, arg.UserID, arg.Lower)
	var i HostedZone
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Zone,
		&i.Status,
		&i.VerificationToken,
		&i.WildcardCertSecret,
		&i.CertIssuedAt,
		&i.VerifiedAt,
		&i.DelegatedAt,
		&i.ExpiresAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findOverlappingHostedZone = `-- name: FindOverlappingHostedZone :one
SELECT id, user_id, zone, status, verification_token, wildcard_cert_secret, cert_issued_at, verified_at, delegated_at, expires_at, last_error, created_at, updated_at FROM hosted_zones
WHERE status != 'failed'
  AND (lower(zone) = lower($1)
       OR lower($1) LIKE '%.' || lower(zone)
       OR lower(zone) LIKE '%.' || lower($1))
LIMIT 1
`

func (q *Queries) FindOverlappingHostedZone(ctx context.Context, lower string) (HostedZone, error) {
	row := q.db.QueryRow(ctx, findOverlappingHostedZone, lower)
	var i HostedZone
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Zone,
		&i.Status,
		&i.VerificationToken,
		&i.WildcardCertSecret,
		&i.CertIssuedAt,
		&i.VerifiedAt,
		&i.DelegatedAt,
		&i.ExpiresAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getHostedZoneByID = `-- name: GetHostedZoneByID :one
SELECT id, user_id, zone, status, verification_token, wildcard_cert_secret, cert_issued_at, verified_at, delegated_at, expires_at, last_error, created_at, updated_at FROM hosted_zones WHERE id = $1
`

func (q *Queries) GetHostedZoneByID(ctx context.Context, id string) (HostedZone, error) {
	row := q.db.QueryRow(ctx, getHostedZoneByID, id)
	var i HostedZone
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Zone,
		&i.Status,
		&i.VerificationToken,
		&i.WildcardCertSecret,
		&i.CertIssuedAt,
		&i.VerifiedAt,
		&i.DelegatedAt,
		&i.ExpiresAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getHostedZoneByZone = `-- name: GetHostedZoneByZone :one
SELECT id, user_id, zone, status, verification_token, wildcard_cert_secret, cert_issued_at, verified_at, delegated_at, expires_at, last_error, created_at, updated_at FROM hosted_zones WHERE lower(zone) = lower($1)
`

func (q *Queries) GetHostedZoneByZone(ctx context.Context, lower string) (HostedZone, error) {
	row := q.db.QueryRow(ctx, getHostedZoneByZone, lower)
	var i HostedZone
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Zone,
		&i.Status,
		&i.VerificationToken,
		&i.WildcardCertSecret,
		&i.CertIssuedAt,
		&i.VerifiedAt,
		&i.DelegatedAt,
		&i.ExpiresAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listHostedZonesByUserID = `-- name: ListHostedZonesByUserID :many
SELECT id, user_id, zone, status, verification_token, wildcard_cert_secret, cert_issued_at, verified_at, delegated_at, expires_at, last_error, created_at, updated_at FROM hosted_zones
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListHostedZonesByUserID(ctx context.Context, userID string) ([]HostedZone, error) {
	rows, err := q.db.Query(ctx, listHostedZonesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []HostedZone{}
	for rows.Next() {
		var i HostedZone
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Zone,
			&i.Status,
			&i.VerificationToken,
			&i.WildcardCertSecret,
			&i.CertIssuedAt,
			&i.VerifiedAt,
			&i.DelegatedAt,
			&i.ExpiresAt,
			&i.LastError,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateHostedZoneActivated = `-- name: UpdateHostedZoneActivated :one
UPDATE hosted_zones
SET status = 'active',
    wildcard_cert_secret = $2,
    cert_issued_at = NOW(),
    last_error = NULL,
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, zone, status, verification_token, wildcard_cert_secret, cert_issued_at, verified_at, delegated_at, expires_at, last_error, created_at, updated_at
`

type UpdateHostedZoneActivatedParams struct {
	ID                 string  `json:"id"`
	WildcardCertSecret *string `json:"wildcard_cert_secret"`
}

func (q *Queries) UpdateHostedZoneActivated(ctx context.Context, arg UpdateHostedZoneActivatedParams) (HostedZone, error) {
	row := q.db.QueryRow(ctx, updateHostedZoneActivated, arg.ID, arg.WildcardCertSecret)
	var i HostedZone
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Zone,
		&i.Status,
		&i.VerificationToken,
		&i.WildcardCertSecret,
		&i.CertIssuedAt,
		&i.VerifiedAt,
		&i.DelegatedAt,
		&i.ExpiresAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateHostedZoneError = `-- name: UpdateHostedZoneError :exec
UPDATE hosted_zones
SET last_error = $2,
    updated_at = NOW()
WHERE id = $1
`

type UpdateHostedZoneErrorParams struct {
	ID        string  `json:"id"`
	LastError *string `json:"last_error"`
}

func (q *Queries) UpdateHostedZoneError(ctx context.Context, arg UpdateHostedZoneErrorParams) error {
	_, err := q.db.Exec(ctx, updateHostedZoneError, arg.ID, arg.LastError)
	return err
}

const updateHostedZoneProvisioning = `-- name: UpdateHostedZoneProvisioning :one
UPDATE hosted_zones
SET status = 'provisioning',
    delegated_at = NOW(),
    last_error = NULL,
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, zone, status, verification_token, wildcard_cert_secret, cert_issued_at, verified_at, delegated_at, expires_at, last_error, created_at, updated_at
`

func (q *Queries) UpdateHostedZoneProvisioning(ctx context.Context, id string) (HostedZone, error) {
	row := q.db.QueryRow(ctx, updateHostedZoneProvisioning, id)
	var i HostedZone
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Zone,
		&i.Status,
		&i.VerificationToken,
		&i.WildcardCertSecret,
		&i.CertIssuedAt,
		&i.VerifiedAt,
		&i.DelegatedAt,
		&i.ExpiresAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateHostedZoneStatus = `-- name: UpdateHostedZoneStatus :one
UPDATE hosted_zones
SET status = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, zone, status, verification_token, wildcard_cert_secret, cert_issued_at, verified_at, delegated_at, expires_at, last_error, created_at, updated_at
`

type UpdateHostedZoneStatusParams struct {
	ID     string `json:"id"`
	Status string `json:"status"`
}

func (q *Queries) UpdateHostedZoneStatus(ctx context.Context, arg UpdateHostedZoneStatusParams) (HostedZone, error) {
	row := q.db.QueryRow(ctx, updateHostedZoneStatus, arg.ID, arg.Status)
	var i HostedZone
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Zone,
		&i.Status,
		&i.VerificationToken,
		&i.WildcardCertSecret,
		&i.CertIssuedAt,
		&i.VerifiedAt,
		&i.DelegatedAt,
		&i.ExpiresAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateHostedZoneTXTVerified = `-- name: UpdateHostedZoneTXTVerified :one
UPDATE hosted_zones
SET status = 'pending_delegation',
    verified_at = NOW(),
    last_error = NULL,
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, zone, status, verification_token, wildcard_cert_secret, cert_issued_at, verified_at, delegated_at, expires_at, last_error, created_at, updated_at
`

func (q *Queries) UpdateHostedZoneTXTVerified(ctx context.Context, id string) (HostedZone, error) {
	row := q.db.QueryRow(ctx, updateHostedZoneTXTVerified, id)
	var i HostedZone
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Zone,
		&i.Status,
		&i.VerificationToken,
		&i.WildcardCertSecret,
		&i.CertIssuedAt,
		&i.VerifiedAt,
		&i.DelegatedAt,
		&i.ExpiresAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
