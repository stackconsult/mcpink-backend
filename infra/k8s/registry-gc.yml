apiVersion: batch/v1
kind: CronJob
metadata:
  name: registry-gc
  namespace: dp-system
spec:
  schedule: "0 4 * * *"
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 2
  failedJobsHistoryLimit: 3
  jobTemplate:
    spec:
      template:
        spec:
          nodeSelector:
            pool: ops
          tolerations:
            - key: pool
              operator: Equal
              value: ops
              effect: NoSchedule
          restartPolicy: OnFailure
          containers:
            - name: gc
              image: registry:2.8.3@sha256:a3d8aaa63ed8681a604f1dea0aa03f100d5895b6a58ace528858a7b332415373
              env:
                - name: REGISTRY_URL
                  value: http://registry.dp-system.svc.cluster.local:5000
                - name: RETAIN_COUNT
                  value: "2"
              command:
                - /bin/sh
                - -ec
                - |
                  # Install curl/jq when they are not present in the base image.
                  # This keeps the manifest self-contained and avoids custom images.
                  if ! command -v curl >/dev/null 2>&1 || ! command -v jq >/dev/null 2>&1; then
                    apk add --no-cache curl jq >/dev/null
                  fi

                  registry_url="${REGISTRY_URL%/}"
                  retain_count="${RETAIN_COUNT:-2}"

                  # Sanity checks: fail fast on misconfiguration.
                  [ -n "$registry_url" ]
                  [ "$retain_count" -ge 1 ] 2>/dev/null

                  tmp_root="$(mktemp -d)"
                  trap 'rm -rf "$tmp_root"' EXIT

                  echo "registry-gc: starting tag retention (keep ${retain_count} per repository)"

                  # Discover repositories through the API first.
                  # Some registry deployments return 400 for _catalog with large `n`,
                  # so keep this resilient and fall back to on-disk discovery.
                  repos="$(curl -fsS "${registry_url}/v2/_catalog?n=1000" 2>/dev/null | jq -r '.repositories[]?' 2>/dev/null || true)"
                  if [ -z "$repos" ]; then
                    repo_root="/var/lib/registry/docker/registry/v2/repositories"
                    repos="$(find "$repo_root" -type d -name _manifests 2>/dev/null \
                      | sed "s#${repo_root}/##" \
                      | sed 's#/_manifests$##' \
                      | sort -u)"
                  fi
                  if [ -z "$repos" ]; then
                    echo "registry-gc: no repositories found, skipping retention phase"
                  fi

                  for repo in $repos; do
                    echo "registry-gc: evaluating repository '${repo}'"

                    candidates_file="${tmp_root}/candidates.tsv"
                    unique_digests_file="${tmp_root}/unique-digests.tsv"
                    : >"$candidates_file"
                    : >"$unique_digests_file"

                    # Fetch tags for this repository.
                    tags="$(curl -fsS "${registry_url}/v2/${repo}/tags/list" | jq -r '.tags[]?')"
                    if [ -z "$tags" ]; then
                      echo "registry-gc: repository '${repo}' has no tags, skipping"
                      continue
                    fi

                    for tag in $tags; do
                      headers_file="${tmp_root}/headers.txt"

                      # GET manifest so we can read digest header + config digest.
                      manifest_json="$(curl -fsS \
                        -H 'Accept: application/vnd.docker.distribution.manifest.v2+json' \
                        -D "$headers_file" \
                        "${registry_url}/v2/${repo}/manifests/${tag}")"

                      digest="$(awk 'BEGIN{IGNORECASE=1} /^Docker-Content-Digest:/ {gsub("\r","",$2); print $2}' "$headers_file" | tail -n1)"
                      if [ -z "$digest" ]; then
                        echo "registry-gc: warning: could not resolve digest for ${repo}:${tag}, skipping tag"
                        continue
                      fi

                      config_digest="$(printf '%s' "$manifest_json" | jq -r '.config.digest // empty')"
                      if [ -z "$config_digest" ]; then
                        # Keep unknown timestamps at epoch 0 so they are least preferred.
                        created_epoch="0"
                      else
                        created_epoch="$(curl -fsS "${registry_url}/v2/${repo}/blobs/${config_digest}" \
                          | jq -r '(.created // "" | sub("\\.[0-9]+Z$"; "Z") | fromdateiso8601?) // 0')"
                        [ -n "$created_epoch" ] || created_epoch="0"
                      fi

                      printf '%s\t%s\t%s\n' "$created_epoch" "$digest" "$tag" >>"$candidates_file"
                    done

                    # Deduplicate by digest: keep the newest timestamp seen for each digest.
                    awk -F'\t' '
                      {
                        if (!($2 in max) || $1 > max[$2]) {
                          max[$2] = $1
                        }
                      }
                      END {
                        for (digest in max) {
                          printf "%s\t%s\n", max[digest], digest
                        }
                      }
                    ' "$candidates_file" | sort -t "$(printf '\t')" -k1,1nr >"$unique_digests_file"

                    digest_count="$(wc -l <"$unique_digests_file" | tr -d ' ')"
                    if [ "$digest_count" -le "$retain_count" ]; then
                      echo "registry-gc: repository '${repo}' already within retention target (${digest_count} digests)"
                      continue
                    fi

                    # Delete digests older than the newest ${retain_count}.
                    # DELETE is idempotent: 404 means it was already removed.
                    sed -n "$((retain_count + 1)),\$p" "$unique_digests_file" | cut -f2 | while IFS= read -r old_digest; do
                      [ -n "$old_digest" ] || continue
                      code="$(curl -sS -o /dev/null -w '%{http_code}' -X DELETE \
                        "${registry_url}/v2/${repo}/manifests/${old_digest}")"
                      case "$code" in
                        202) echo "registry-gc: deleted ${repo}@${old_digest}" ;;
                        404) echo "registry-gc: already absent ${repo}@${old_digest} (idempotent)" ;;
                        *)
                          echo "registry-gc: warning: delete failed for ${repo}@${old_digest} (HTTP ${code})"
                          ;;
                      esac
                    done
                  done

                  echo "registry-gc: running blob garbage collection"
                  /bin/registry garbage-collect /etc/docker/registry/config.yml --delete-untagged
                  echo "registry-gc: completed"
              volumeMounts:
                - name: data
                  mountPath: /var/lib/registry
          volumes:
            - name: data
              hostPath:
                path: /mnt/registry
                type: DirectoryOrCreate
