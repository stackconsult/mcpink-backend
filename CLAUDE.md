# Project Guidelines

This repository serves as a Go project template.

## Quick Start (New Project)

1. Clone and rename module in `go.mod`
2. Update import paths throughout codebase
3. Configure `application.yaml` for your environment
4. Define your GraphQL schema in `internal/graph/schema.graphqls`
5. Add migrations in `internal/storage/pg/migrations/`
6. Add sqlc queries in `internal/storage/pg/queries/<domain>/`
7. Run `make sqlc && make gqlgen`
8. Wire new services in `cmd/server/main.go`

## Project Structure

```
autoclip/
├── cmd/                           # Application binaries
│   └── server/                    # Main server binary
│       └── main.go
├── internal/                      # Private application code
│   ├── authz/                     # Authentication/authorization
│   ├── bootstrap/                 # Dependency injection setup (fx providers)
│   ├── graph/                     # GraphQL layer
│   │   ├── schema.graphqls        # GraphQL schema definitions
│   │   ├── schema.resolvers.go    # Resolver implementations
│   │   ├── resolver.go            # Resolver struct
│   │   ├── generated.go           # Auto-generated (do not edit)
│   │   └── model/
│   │       └── models_gen.go      # Auto-generated models (do not edit)
│   └── storage/
│       └── pg/
│           ├── queries/           # SQL query files for sqlc
│           │   └── <domain>/
│           │       └── <domain>.sql
│           ├── migrations/        # Database migrations (goose)
│           │   └── NNNN_<name>.sql
│           ├── generated/         # Auto-generated by sqlc (do not edit)
│           │   └── <domain>/
│           ├── database.go        # Database connection
│           └── migrations.go      # Migration runner
├── application.yaml               # Application configuration
├── sqlc.yaml                      # sqlc configuration
├── gqlgen.yml                     # gqlgen configuration
└── Makefile
```

## Dependency Injection (uber-go/fx)

All binaries use fx for dependency injection.

### IMPORTANT: No Wrapper Functions

**NEVER create wrapper functions in bootstrap that just call the original constructor.** Use the original package function directly in fx.Provide.

Bad (unnecessary wrapper):
```go
// bootstrap/auth.go - DON'T DO THIS
func NewAuthHandlers(svc *auth.Service, cfg auth.Config) *auth.Handlers {
    return auth.NewHandlers(svc, cfg)
}

// main.go
fx.Provide(bootstrap.NewAuthHandlers)
```

Good (use directly):
```go
// main.go
fx.Provide(auth.NewHandlers)
```

Only create bootstrap functions when actual adaptation is needed (e.g., combining multiple services into a router).

### Main function pattern

```go
package main

import (
    "github.com/augustdev/autoclip/internal/auth"
    "github.com/augustdev/autoclip/internal/bootstrap"
    "github.com/augustdev/autoclip/internal/storage/pg"
    "go.uber.org/fx"
)

func main() {
    fx.New(
        fx.Provide(
            bootstrap.NewLogger,
            bootstrap.NewConfig,
            pg.NewDatabase,
            auth.NewService,    // Use package constructors directly
            auth.NewHandlers,   // Not bootstrap wrappers
        ),
        fx.Invoke(
            bootstrap.StartServer,
        ),
    ).Run()
}
```

## Database

### Adding New Queries (sqlc)

1. Create SQL file in `internal/storage/pg/queries/<domain>/<domain>.sql`
2. Add sqlc configuration block to `sqlc.yaml`:
   ```yaml
   - engine: "postgresql"
     queries: "internal/storage/pg/queries/<domain>"
     schema: "internal/storage/pg/migrations"
     gen:
       go:
         package: "<domain>"
         out: "internal/storage/pg/generated/<domain>"
         sql_package: "pgx/v5"
         emit_json_tags: true
         emit_interface: true
         emit_empty_slices: true
   ```
3. Run `make sqlc`

### Adding New Migrations

1. Create migration file: `internal/storage/pg/migrations/NNNN_<name>.sql`
2. Use goose format with `-- +goose Up` and `-- +goose Down` annotations

## GraphQL

### Modifying Schema

1. Edit `internal/graph/schema.graphqls`
2. Run `make gqlgen`
3. Implement resolver methods in `internal/graph/schema.resolvers.go`

### Directives

- `@isAuthenticated` - Requires valid authentication token

## Configuration

### IMPORTANT: No mapstructure Tags

**NEVER use `mapstructure` struct tags.** Viper automatically maps lowercase yaml keys to Go struct fields. Use lowercase keys in yaml that match the lowercase version of your Go field names.

Example:
```yaml
# application.yaml
auth:
  jwtsecret: "secret"      # maps to JWTSecret
  sessioncookiename: "x"   # maps to SessionCookieName
```

```go
type Config struct {
    JWTSecret         string  // No tags needed
    SessionCookieName string
}
```

### Pattern

Each package defines its own `Config` struct. The `bootstrap.Config` aggregates all package configs using `fx.Out` for dependency injection.

**Package-level config** (e.g., `internal/storage/pg/database.go`):
```go
type DbConfig struct {
    URL             string
    MaxConns        int32
    MinConns        int32
    MaxConnLifetime time.Duration
    MaxConnIdleTime time.Duration
}
```

**Aggregated config** (`internal/bootstrap/config.go`):
```go
type Config struct {
    fx.Out

    GraphQLAPI GraphQLAPIConfig
    Db         pg.DbConfig
    // Add new package configs here
}
```

### Configuration Sources

1. `application.yaml` - Primary config file (viper)
2. Environment variables - Override yaml values using `_` as separator
   - Example: `DB_URL` overrides `db.url`
   - Example: `GRAPHQLAPI_PORT` overrides `graphqlapi.port`
3. `APPLICATION_CONFIG` env var - Custom config file path

### Adding New Configuration

1. Define `Config` struct in the package with `mapstructure` tags
2. Add corresponding section to `application.yaml`
3. Import and embed in `bootstrap.Config`
4. Update `NewConfig()` to unmarshal the new section

## Code Style

- NEVER use comments unless documenting complex or non-standard implementations
- Use meaningful variable and function names that are self-documenting
- Keep functions small and focused
- Follow standard Go conventions

## Adding a New Domain

Example: Adding an `orders` domain

1. **Migration**: Create `internal/storage/pg/migrations/0002_orders.sql`
2. **Queries**: Create `internal/storage/pg/queries/orders/orders.sql`
3. **sqlc config**: Add block to `sqlc.yaml`:
   ```yaml
   - engine: "postgresql"
     queries: "internal/storage/pg/queries/orders"
     schema: "internal/storage/pg/migrations"
     gen:
       go:
         package: "orders"
         out: "internal/storage/pg/generated/orders"
         sql_package: "pgx/v5"
         emit_json_tags: true
         emit_interface: true
         emit_empty_slices: true
   ```
4. **Generate**: `make sqlc`
5. **Service**: Create `internal/orders/service.go` with config and service logic
6. **GraphQL**: Add types/queries/mutations to `internal/graph/schema.graphqls`
7. **Generate**: `make gqlgen`
8. **Resolvers**: Implement in `internal/graph/schema.resolvers.go`
9. **Wire**: Add providers to `cmd/server/main.go`

## Make Commands

```bash
make run-server    # Run the server
make sqlc          # Generate sqlc code
make gqlgen        # Generate GraphQL code
```
